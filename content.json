{"meta":{"title":"awstudio's blog","subtitle":"","description":"","author":"Arthur Wang","url":"http://arthurwang.top","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-02-02T08:11:29.000Z","updated":"2020-02-02T08:11:29.000Z","comments":true,"path":"404.html","permalink":"http://arthurwang.top/404.html","excerpt":"","text":"404 Not Found 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"所有分类","date":"2020-02-01T16:43:23.000Z","updated":"2020-02-01T16:41:24.000Z","comments":true,"path":"categories/index.html","permalink":"http://arthurwang.top/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-02-01T16:44:23.000Z","updated":"2020-02-01T16:44:23.000Z","comments":true,"path":"tags/index.html","permalink":"http://arthurwang.top/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-02-01T18:20:22.000Z","updated":"2020-02-01T18:20:22.000Z","comments":true,"path":"about/index.html","permalink":"http://arthurwang.top/about/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-02-06T09:33:44.000Z","updated":"2020-02-06T09:33:44.000Z","comments":true,"path":"friends/index.html","permalink":"http://arthurwang.top/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"Vue Q&A","slug":"vue-qa","date":"2020-03-31T13:34:47.000Z","updated":"2020-04-01T09:51:16.083Z","comments":true,"path":"2020/03/31/vue-qa/","link":"","permalink":"http://arthurwang.top/2020/03/31/vue-qa/","excerpt":"","text":"1、跟keep-alive有关的生命周期是哪些？描述下这些生命周期 activated和deactivated两个生命周期函数 1.activated：当组件激活时，钩子触发的顺序是created-&gt;mounted-&gt;activated 2.deactivated: 组件停用时会触发deactivated，当再次前进或者后退的时候只触发activated 2、vue怎么实现强制刷新组件？ v-if：当v-if的值发生变化时，组件都会被重新渲染一遍。因此，利用v-if指令的特性，可以达到强制 this.$forceUpdate() 3、vue如何优化首页的加载速度？ ① 第三方js库按CDN引入（一、cdn引入 二、去掉第三方库引入的import 三、把第三方库的js文件从打包文件里去掉） ② vue-router路由懒加载 ③ 压缩图片资源 ④ 静态文件本地缓存 ⑤ 服务器端SSR渲染 4、vue中data的属性可以和methods中的方法同名吗？为什么？ 不可以。因为，Vue会把methods和data的东西，全部代理到Vue生成的对象中，会产生覆盖所以最好不要同名。[Vue warn]: Method &quot;msg&quot; has already been defined as a data property. 5、怎么给vue定义全局的方法？ vue.prototype.方法名 6、Vue 2.0 不再支持在 v-html 中使用过滤器怎么办？ ①全局方法（推荐） Vue.prototype.msg = function(msg) { return xxx } ②computed方法 ③$options.filters(推荐) 123456789filters: &#123; msg: function(msg) &#123; return msg.replace(/\\n/g, \"&lt;br&gt;\") &#125;&#125;,data: &#123; content: 'xxx'&#125;&lt;div v-html=\"$options.filters.msg(content)\"&gt;&lt;/div&gt; 7、怎么解决vue打包后静态资源图片失效的问题？ 答：将静态资源的存放位置放在src目录下 8、vue中怎么重置data？ Object.assign() Object.assign()方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 123456var o1 = &#123; a: 1 &#125;;var o2 = &#123; b: 2 &#125;;var o3 = &#123; c: 3 &#125;;var obj = Object.assign(o1, o2, o3);console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125;console.log(o1); // &#123; a: 1, b: 2, c: 3 &#125;, 注意目标对象自身也会改变。 注意，具有相同属性的对象，同名属性，后边的会覆盖前边的。 由于 Object.assign() 有上述特性，所以我们在Vue中可以这样使用： Vue组件可能会有这样的需求：在某种情况下，需要重置Vue组件的data数据。此时，我们可以通过this.获取当前状态下的，通过options.data()获取该组件初始状态下的data。 然后只要使用Object.assign(this.options.data())就可以将当前状态的data重置为初始状态。 9、页面中定义一个定时器，在哪个阶段清除？ 答案：在 beforeDestroy 中销毁定时器。 ①为什么销毁它： 在页面a中写了一个定时器，比如每隔一秒钟打印一次1，当我点击按钮进入页面b的时候，会发现定时器依然在执行，这是非常消耗性能的。 ②解决方案1： 12345678mounted()&#123; this.timer = setInterval(()=&gt;&#123; console.log(1) &#125;,1000)&#125;,beforeDestroy()&#123; clearInterval(this.timer)&#125; 方案1有两点不好的地方，引用尤大的话来说就是： 它需要在这个组件实例中保存这个 timer，如果可以的话最好只有生命周期钩子可以访问到它。这并不算严重的问题，但是它可以被视为杂物。 我们的建立代码独立于我们的清理代码，这使得我们比较难于程序化的清理我们建立的所有东西。 方案2（推荐）：该方法是通过$once这个事件侦听器在定义完定时器之后的位置来清除定时器 12345678mounted()&#123; const timer &#x3D; setInterval(()&#x3D;&gt;&#123; console.log(1) &#125;,1000) this.$once(&#39;hook:beforeDestroy&#39;,()&#x3D;&gt;&#123; clearInterval(timer) &#125;)&#125; 10、父组件如何获取子组件的数据，子组件如何获取父组件的数据，父子组件如何传值？ $children $refs $emit $parent props ③ inheritAttrs 这是@2.4新增的属性和接口。inheritAttrs属性控制子组件html属性上是否显示父组件的提供的属性。 12&#x2F;&#x2F;父组件&lt;HelloWorld ref&#x3D;&quot;hello&quot; :desc&#x3D;&quot;desc&quot; :keysword&#x3D;&quot;keysword&quot; :message&#x3D;&quot;message&quot;&gt;&lt;&#x2F;HelloWorld&gt; 实际情况，我们只需要message，那其他两个属性则会被当做普通的html元素插在子组件的根元素上。 这样做会使组件预期功能变得模糊不清，这个时候，在子组件中写入，inheritAttrs：false ，这些没用到的属性便会被去掉，true的话，就会显示。 如果，父组件中没被需要的属性，跟子组件本来的属性冲突的时候，则依据父组件。 上述这些没被用到的属性，如何被获取呢？这就用到了$attrs ③ $attrs 作用：可以获取到没有使用的注册属性，如果需要，我们在这也可以往下继续传递。 就上上述没有被用到的desc和keysword就能通过$attrs获取到。 通过$attrs的这个特性可以父组件传递到孙组件，免除父组件传递到子组件，再从子组件传递到孙组件的麻烦 可以看出通过 v-bind=”$attrs”将数据传到孙组件中 除了以上，provide / inject 也适用于 隔代组件通信，尤其是获取祖先组件的数据，非常方便。 ④ provide inject 12345678910111213141516&lt;template&gt; &lt;div&gt; &lt;childOne&gt;&lt;&#x2F;childOne&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; import childOne from &#39;..&#x2F;components&#x2F;test&#x2F;ChildOne&#39; export default &#123; name: &quot;Parent&quot;, provide: &#123; for: &quot;demo&quot; &#125;, components:&#123; childOne &#125; &#125; 在这里我们在父组件中provide for这个变量，然后直接设置三个组件（childOne、childTwo 、childThird）并且一层层不断内嵌其中， 而在最深层的childThird组件中我们可以通过inject获取for这个变量 12345678910111213141516&lt;template&gt; &lt;div&gt; &#123;&#123;demo&#125;&#125; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; name: &quot;&quot;, inject: [&#39;for&#39;], data() &#123; return &#123; demo: this.for &#125; &#125; &#125;&lt;&#x2F;script&gt; 11、自定义指令如何定义，它的生命周期是什么？ 通过 Vue.directive() 来定义全局指令 有几个可用的钩子（生命周期）, 每个钩子可以选择一些参数. 钩子如下: bind: 一旦指令附加到元素时触发 inserted: 一旦元素被添加到父元素时触发 update: 每当元素本身更新(但是子元素还未更新)时触发 componentUpdate: 每当组件和子组件被更新时触发 unbind: 一旦指令被移除时触发。 bind和update也许是这五个里面最有用的两个钩子了 每个钩子都有el, binding, 和vnode参数可用. update和componentUpdated钩子还暴露了oldVnode, 以区分传递的旧值和较新的值. el就是所绑定的元素. binding是一个保护传入钩子的参数的对象. 有很多可用的参数, 包括name, value, oldValue, expression, arguments, arg及修饰语. vnode有一个更不寻常的用例, 它可用于你需要直接引用到虚拟DOM中的节点. binding和vnode都应该被视为只读. 12、vue生命周期，各个阶段简单讲一下？ breforeCreate（）：实例创建前，这个阶段实例的data和methods是读不到的。 created（）：实例创建后，这个阶段已经完成数据观测，属性和方法的运算，watch/event事件回调，mount挂载阶段还没有开始。$el属性目前不可见，数据并没有在DOM元素上进行渲染。 created完成之后，进行template编译等操作，将template编译为render函数，有了render函数后才会执行beforeMount（） beforeMount（）：在挂载开始之前被调用：相关的 render 函数首次被调用 mounted（）：挂载之后调用，el选项的DOM节点被新创建的 vm.$el 替换，并挂载到实例上去之后调用此生命周期函数，此时实例的数据在DOM节点上进行渲染 后续的钩子函数执行的过程都是需要外部的触发才会执行 有数据的变化，会调用beforeUpdate，然后经过Virtual Dom，最后updated更新完毕，当组件被销毁的时候，会调用beforeDestory，以及destoryed。 13、watch 和 computed的区别？ computed： ①有缓存机制；②不能接受参数；③可以依赖其他computed，甚至是其他组件的data；④不能与data中的属性重复 watch： ①可接受两个参数；②监听时可触发一个回调，并做一些事情；③监听的属性必须是存在的；④允许异步 watch配置：handler、deep（是否深度）、immeditate （是否立即执行） 总结： 当有一些数据需要随着另外一些数据变化时，建议使用computed 当有一个通用的响应数据变化的时候，要执行一些业务逻辑或异步操作的时候建议使用watch computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；运用场景： 当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算； 当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。 14、computed中的getter和setter ① computed 中可以分成 getter（读取） 和 setter（设值） ② 一般情况下是没有 setter 的，computed 预设只有 getter ，也就是只能读取，不能改变设值。 注意：不是说我们更改了getter里使用的变量，就会触发computed的更新，前提是computed里的值必须要在模板里使用才行。如果将去掉，get方法是不会触发的。 注意：并不是触发了setter也就会触发getter，他们两个是相互独立的。我们这里修改了fullName会触发getter是因为setter函数里有改变firstName 和 lastName 值的代码，这两个值改变了，fullName依赖于这两个值，所以便会自动改变。 15、导航钩子 ①全局导航守卫 前置守卫 123router.beforeEach((to, from, next) =&gt; &#123; //do something&#125;) 后置钩子（没有next参数） 123router.afterEach((to, from) =&gt; &#123; //do something &#125;) ②路由独享守卫 1234567891011cont router = new VueRouter(&#123; routes: [ &#123; path: '/file', component: File, beforeEnter: (to, from ,next) =&gt; &#123; // do someting &#125; &#125; ]&#125;); ③ 组件内的导航钩子 组件内的导航钩子主要有这三种：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave。他们是直接在路由组件内部直接进行定义的 beforeRouteEnter 注：beforeRouteEnter 不能获取组件实例 this，因为当守卫执行前，组件实例被没有被创建出来，我们可以通过给 next 传入一个回调来访问组件实例。在导航被确认时，会执行这个回调，这时就可以访问组件实例了 仅仅是 beforRouteEnter 支持给 next 传递回调，其他两个并不支持，因为剩下两个钩子可以正常获取组件实例 this 16、如何通过路由将数据传入下一个跳转的页面呢？ 答： params 和 query params 123456789传参this.$router.push(&#123; name:\"detail\", params:&#123; name:'xiaoming', &#125;&#125;);接受this.$route.params.name query 123456789传参this.$router.push(&#123; path:'/detail', query:&#123; name:\"xiaoming\" &#125; &#125;)接受 //接收参数是this.$routethis.$route.query.id 那query和params什么区别呢？ ① params只能用name来引入路由，query既可以用name又可以用path（通常用path） ② params类似于post方法，参数不会再地址栏中显示；query类似于get请求，页面跳转的时候，可以在地址栏看到请求参数 17、this.$router 和this.$route有何区别？ $router为VueRouter实例，想要导航到不同URL，则使用$router.push方法 $route为当前router跳转对象，里面可以获取name、path、query、params等 18、es6 的特有的类型， 常用的操作数组的方法都有哪些？ es6新增的主要的特性： ① let const 两者都有块级作用域 ② 箭头函数 ③ 模板字符串 ④ 解构赋值 ⑤ for of循环 ⑥ import 、export 导入导出 ⑦ set数据结构 ⑧ …展开运算符 ⑨ 修饰器 @ ⑩ class类继承 ⑪ async、await ⑫ promise ⑬ Symbol ⑭ Proxy代理 操作数组常用的方法： es5：concat 、join 、push、pop、shift、unshift、slice、splice、substring和substr 、sort、 reverse、indexOf和lastIndexOf 、every、some、filter、map、forEach、reduce es6：find、findIndex、fill、copyWithin、Array.from、Array.of、entries、values、key、includes 19、vue双向绑定原理？ 通过 Object.defineProperty() 来劫持各个属性的setter,getter，在数据变动时发布消息给订阅者，触发相应的监听回调 20、vue-router的实现原理，history和hash模式有什么区别？ vue-router有两种模式，hash模式和history模式 hash模式 url中带有#的便是hash模式，#后面是hash值，它的变化会触发hashchange 这个事件。 通过这个事件我们就可以知道 hash 值发生了哪些变化。然后我们便可以监听hashchange来实现更新页面部分内容的操作： 另外，hash 值的变化，并不会导致浏览器向服务器发出请求，浏览器不发出请求，也就不会刷新页面。 history模式 history api可以分为两大部分，切换和修改 ① 切换历史状态 包括back,forward,go三个方法，对应浏览器的前进，后退，跳转操作 1234history.go(-2);&#x2F;&#x2F;后退两次history.go(2);&#x2F;&#x2F;前进两次history.back(); &#x2F;&#x2F;后退hsitory.forward(); &#x2F;&#x2F;前进 ② 修改历史状态 包括了pushState,replaceState两个方法,这两个方法接收三个参数:stateObj,title,url 123456789history.pushState(&#123;color:&#39;red&#39;&#125;, &#39;red&#39;, &#39;red&#39;&#125;)window.onpopstate &#x3D; function(event)&#123; console.log(event.state) if(event.state &amp;&amp; event.state.color &#x3D;&#x3D;&#x3D; &#39;red&#39;)&#123; document.body.style.color &#x3D; &#39;red&#39;; &#125;&#125;history.back();history.forward(); 通过pushstate把页面的状态保存在state对象中，当页面的url再变回这个url时，可以通过event.state取到这个state对象，从而可以对页面状态进行还原，这里的页面状态就是页面字体颜色，其实滚动条的位置，阅读进度，组件的开关的这些页面状态都可以存储到state的里面。 history缺点： 1：hash 模式下，仅hash符号之前的内容会被包含在请求中，如http://www.a12c.com,因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回404错误。 2：history模式下，前端的URL必须和实际向后端发起请求的URL一致。如http://www.a12c.com/book/a。如果后端缺少对/book/a 的路由处理，将返回404错误 21、vue能监听到数组变化的方法有哪些？为什么这些方法能监听到呢？ Vue.js观察数组变化主要通过以下7个方法（push、pop、shift、unshift、splice、sort、reverse） 大家知道，通过Object.defineProperty()劫持数组为其设置getter和setter后，调用的数组的push、splice、pop等方法改变数组元素时并不会触发数组的setter，继而数组的数据变化并不是响应式的，但是vue实际开发中却是实时响应的，是因为vue重写了数组的push、splice、pop等方法 从源码中可以看出，ob.dep.notify()将当前数组的变更通知给其订阅者，这样当使用重写后方法改变数组后，数组订阅者会将这边变化更新到页面中 22、怎么缓存当前组件，怎么更新 keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性： 一般结合路由和动态组件一起使用，用于缓存组件； 提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高； 对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。 123456789101112131415161718192021&lt;keep-alive&gt; &lt;router-view&gt;&lt;&#x2F;router-view&gt;&lt;&#x2F;keep-alive&gt;&lt;!-- 这里是需要keepalive的 --&gt;&lt;keep-alive&gt; &lt;router-view v-if&#x3D;&quot;$route.meta.keepAlive&quot;&gt;&lt;&#x2F;router-view&gt;&lt;&#x2F;keep-alive&gt;&lt;!-- 这里不会被keepalive --&gt;&lt;router-view v-if&#x3D;&quot;!$route.meta.keepAlive&quot;&gt;&lt;&#x2F;router-view&gt;&#123; path: &#39;&#39;, name: &#39;&#39;, component: , meta: &#123;keepAlive: true&#125; &#x2F;&#x2F; 这个是需要keepalive的&#125;,&#123; path: &#39;&#39;, name: &#39;&#39;, component: , meta: &#123;keepAlive: false&#125; &#x2F;&#x2F; 这是不会被keepalive的&#125; 如果缓存的组件想要清空数据或者执行初始化方法，在加载组件的时候调用activated钩子函数，如下： 123activated: function () &#123; this.data = '';&#125; 23、axios怎么解决跨域？ 使用axios直接进行跨域访问不可行，我们需要配置代理 代理可以解决的原因： 因为客户端请求服务端的数据是存在跨域问题的，而服务器和服务器之间可以相互请求数据，是没有跨域的概念（如果服务器没有设置禁止跨域的权限问题），也就是说，我们可以配置一个代理的服务器可以请求另一个服务器中的数据，然后把请求出来的数据返回到我们的代理服务器中，代理服务器再返回数据给我们的客户端，这样我们就可以实现跨域访问数据 1.配置BaseUrl 123import axios from 'axios'Vue.prototype.$axios = axiosaxios.defaults.baseURL = '/api' //关键代码 2.配置代理 在config文件夹下的index.js文件中的proxyTable字段中，作如下处理： 12345678910111213proxyTable: &#123; '/api': &#123; target:'http://api.douban.com/v2', // 你请求的第三方接口 changeOrigin:true, // 在本地会创建一个虚拟服务端，然后发送请求的数据，并同时接收请求的数据，//这样服务端和服务端进行数据的交互就不会有跨域问题 pathRewrite:&#123; // 路径重写， '^/api': '' // 替换target中的请求地址，也就是说以后你在请求http://api.douban.com/v2/XXXXX//这个地址的时候直接写成/api即可。 &#125; &#125;&#125; 在具体使用axios的地方，修改url如下即可 12345678axios.get(&quot;&#x2F;movie&#x2F;top250&quot;).then((res) &#x3D;&gt; &#123; res &#x3D; res.data if (res.errno &#x3D;&#x3D;&#x3D; ERR_OK) &#123; this.themeList&#x3D;res.data; &#125; &#125;).catch((error) &#x3D;&gt; &#123; console.warn(error)&#125;) 原理： 因为我们给url加上了前缀/api，我们访问/movie/top250就当于访问了：localhost:8080/api/movie/top250（其中localhost:8080是默认的IP和端口）。 在index.js中的proxyTable中拦截了/api,并把/api及其前面的所有替换成了target中的内容，因此实际访问Url是http://api.douban.com/v2/movie/top250。 至此，纯前端配置代理解决axios跨域得到解决 24、怎么实现路由懒加载 第一种（最常用）： 123456const Foo = () =&gt; import('./Foo.vue')const router = new VueRouter(&#123; routes: [ &#123; path: '/foo', component: Foo &#125; ]&#125;) 第二种： 12345678910const router = new Router(&#123; routes: [ &#123; path: '/index', component: (resolve) =&gt; &#123; require(['../components/index'], resolve) // 这里是你的模块 不用import去引入了 &#125; &#125; ]&#125;) 第三种require.ensure（官方推荐）： 123456789101112// r就是resolveconst list = r =&gt; require.ensure([], () =&gt; r(require('../components/list/list')), 'list');// 路由也是正常的写法 这种是官方推荐的写的 按模块划分懒加载 const router = new Router(&#123; routes: [ &#123; path: '/list/blog', component: list, name: 'blog' &#125; ]&#125;) 25、动态路由 26、切换路由，滚动到顶部或者原先位置 当创建一个 Router 实例，可以提供一个 scrollBehavior 方法： 1234567注意: 这个功能只在 HTML5 history 模式下可用。const router = new VueRouter(&#123; routes: [...], scrollBehavior (to, from, savedPosition) &#123; // return 期望滚动到哪个的位置 &#125;&#125;) scrollBehavior 方法接收 to 和 from 路由对象。第三个参数 savedPosition 当且仅当 popstate 导航 (通过浏览器的 前进/后退 按钮触发) 时才可用。 1234scrollBehavior (to, from, savedPosition) &#123; return &#123; x: 0, y: 0 &#125;&#125;对于所有路由导航，简单地让页面滚动到顶部。 12345678返回 savedPosition，在按下 后退/前进 按钮时，在滚动条位置，就会像浏览器的原生表现那样：scrollBehavior (to, from, savedPosition) &#123; if (savedPosition) &#123; return savedPosition &#125; else &#123; return &#123; x: 0, y: 0 &#125; &#125;&#125; 还可以在main.js入口文件配合vue-router写这个 123router.afterEach((to,from,next) =&gt; &#123; window.scrollTo(0,0);&#125;); 27、vue-router响应参数变化 当使用路由参数时，比如： 1&#123;path:’&#x2F;list&#x2F;:id’component:Foo&#125; 从 /list/aside导航到 /list/foo，原来的组件实例会被复用。 因为两个路由都渲染同个组件Foo，比起销毁再创建，复用则更加高效。 不过，这也意味着组件的生命周期钩子不会再被调用。 如果跳转到相同的路由还会报以下错误: 1\"Navigating to current location is not allowed\" 这个时候我们需要重写push方法，在src/router/index.js 里面import VueRouter from ‘vue-router’下面写入下面方法即可 1234const routerPush = VueRouter.prototype.pushVueRouter.prototype.push = function push(location) &#123; return routerPush.call(this, location).catch(error=&gt; error)&#125; 如何响应不同的数据呢？ ① 复用组件时，想对路由参数的变化作出响应的话，你可以简单地 watch (监测变化) $route 对象： 12345678const User = &#123; template: '...', watch: &#123; '$route' (to, from) &#123; // 对路由变化作出响应... &#125; &#125;&#125; ② 使用beforeRouteUpdate 1234567const User = &#123; template: '...', beforeRouteUpdate (to, from, next) &#123; // react to route changes... // don't forget to call next() &#125;&#125; 注意： （1）从同一个组件跳转到同一个组件。 （2）生命周期钩子created和mounted都不会调用。 28、vue模板中为什么以_、$开始的变量无法渲染？ 名字以 _ 或 $开始的属性不会被 Vue 实例代理，因为它们可能与 Vue 的内置属性与 API 方法冲突。用 vm.$data._property 访问它们。 29、vue中，如何监听一个对象内部的变化？ 方法①：对整个obj深层监听 12345678910watch:&#123; obj:&#123; handler(newValue,oldValue)&#123; console.log('obj changed') &#125;, deep: true,//深度遍历 immediate: true //默认第一次绑定的时候不会触发watch监听，值为true时可以在最初绑定的时候执行 &#125;&#125; 方法② ：指定key 1234567watch: &#123; \"dataobj.name\": &#123; handler(newValue, oldValue) &#123; console.log(\"obj changed\"); &#125; &#125; &#125; 方法③：computed 12345computed()&#123; ar()&#123; return this.obj.name &#125;&#125; 30、v-for循环时为什么要加key？ key的作用主要是为了高效的更新虚拟DOM，是因为Virtual DOM 使用Diff算法实现的原因。 当某一层有很多相同的节点时，也就是列表节点时，Diff算法的更新过程默认情况下也是遵循以上原则。 所以我们需要使用key来给每个节点做一个唯一标识，Diff算法就可以正确的识别此节点，找到正确的位置区插入新的节点。 31、$nextTick用过吗，有什么作用？ 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。 解决的问题：有些时候在改变数据后立即要对dom进行操作，此时获取到的dom仍是获取到的是数据刷新前的dom，无法满足需要，这个时候就用到了$nextTick。 32、vue和react的区别是什么？ ① React严格上只针对MVC的view层,Vue则是MVVM模式 ② virtual DOM不一样,vue会跟踪每一个组件的依赖关系,不需要重新渲染整个组件树.而对于React而言,每当应用的状态被改变时,全部组件都会重新渲染,所以react中会需要shouldComponentUpdate这个生命周期函数方法来进行控制 ③ 组件写法不一样, React推荐的做法是 JSX + inline style, 也就是把HTML和CSS全都写进JavaScript了,即’all in js’; Vue推荐的做法是webpack+vue-loader的单文件组件格式,即html,css,jd写在同一个文件; ④ 数据绑定: vue实现了数据的双向绑定,react数据流动是单向的 ⑤ state对象在react应用中不可变的,需要使用setState方法更新状态;在vue中,state对象不是必须的,数据由data属性在vue对象中管理 33、直接给一个数组项赋值，Vue 能检测到变化吗？由于 JavaScript 的限制，Vue 不能检测到以下数组的变动： 当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue 当你修改数组的长度时，例如：vm.items.length = newLength 为了解决第一个问题，Vue 提供了以下操作方法： 123456 // Vue.set Vue.set(vm.items, indexOfItem, newValue) // vm.$set，Vue.set的一个别名 vm.$set(vm.items, indexOfItem, newValue) // Array.prototype.splice vm.items.splice(indexOfItem, 1, newValue) 为了解决第二个问题，Vue 提供了以下操作方法： 12// Array.prototype.splice vm.items.splice(newLength) 34、Vue 的父组件和子组件生命周期钩子函数执行顺序？ Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分： 加载渲染过程父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted 子组件更新过程父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated 父组件更新过程父 beforeUpdate -&gt; 父 updated 销毁过程父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed 35、在哪个生命周期内调用异步请求？ 可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点： 能更快获取到服务端数据，减少页面 loading 时间； ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性； 36、在什么阶段才能访问操作DOM？ 在钩子函数 mounted 被调用前，Vue 已经将编译好的模板挂载到页面上，所以在 mounted 中可以访问操作 DOM。vue 具体的生命周期示意图可以参见如下，理解了整个生命周期各个阶段的操作，关于生命周期相关的面试题就难不倒你了。 37、父组件可以监听到子组件的生命周期吗？比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现： 123456&#x2F;&#x2F; Parent.vue &lt;Child @mounted&#x3D;&quot;doSomething&quot;&#x2F;&gt;&#x2F;&#x2F; Child.vue mounted() &#123; this.$emit(&quot;mounted&quot;); &#125; 以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示： 1234567891011 // Parent.vue &lt;Child @hook:mounted=\"doSomething\" &gt;&lt;/Child&gt; doSomething() &#123; console.log('父组件监听到 mounted 钩子函数 ...'); &#125;, // Child.vue mounted()&#123; console.log('子组件触发 mounted 钩子函数 ...'); &#125;, // 以上输出顺序为： // 子组件触发 mounted 钩子函数 ... // 父组件监听到 mounted 钩子函数 ... 当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。 组件调用了$on监听的事件名符合以hook:开头，当前实例的vm._hasHookEvent会为true，组件就会在对应生命周期的时候通过emit触发对应的事件vm.$emit(‘hook:’+hook) 38、组件中 data 为什么是一个函数？ 为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？ 123456789101112131415&#x2F;&#x2F; datadata() &#123; return &#123; message: &quot;子组件&quot;, childName:this.name &#125;&#125;&#x2F;&#x2F; new Vuenew Vue(&#123; el: &#39;#app&#39;, router, template: &#39;&lt;App&#x2F;&gt;&#39;, components: &#123;App&#125;&#125;) 因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。 39、v-model 的原理？ 我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件： text 和 textarea 元素使用 value 属性和 input 事件； checkbox 和 radio 使用 checked 属性和 change 事件； select 字段将 value 作为 prop 并将 change 作为事件。 以 input 表单元素为例： 123&lt;input v-model&#x3D;&#39;something&#39;&gt;相当于&lt;input v-bind:value&#x3D;&quot;something&quot; v-on:input&#x3D;&quot;something &#x3D; $event.target.value&quot;&gt; 如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件，如下所示： 123456789101112父组件：&lt;ModelChild v-model=\"message\"&gt;&lt;/ModelChild&gt;子组件：&lt;div&gt;&#123;&#123;value&#125;&#125;&lt;/div&gt;props:&#123; value: String&#125;,methods: &#123; test1()&#123; this.$emit('input', '小红') &#125;,&#125;, 40、Vue 组件间通信有哪几种方式？ Vue 组件间通信是面试常考的知识点之一，这题有点类似于开放题，你回答出越多方法当然越加分，表明你对 Vue 掌握的越熟练。Vue 组件间通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信，下面我们分别介绍每种通信方式且会说明此种方法可适用于哪类组件间通信。 （1）props / $emit 适用 父子组件通信 这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。 （2）ref 与 $parent / $children 适用 父子组件通信 ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例 $parent / $children：访问父 / 子实例 （3）EventBus （$emit / $on） 适用于 父子、隔代、兄弟组件通信 这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。 （4）$attrs/$listeners 适用于 隔代组件通信 $attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind=&quot;$attrs&quot; 传入内部组件。通常配合 inheritAttrs 选项一起使用。 $listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=&quot;$listeners&quot; 传入内部组件 （5）provide / inject 适用于 隔代组件通信 祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。 provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。 （6）Vuex 适用于 父子、隔代、兄弟组件通信 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。 Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。 41、你使用过 Vuex 吗？ Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。 （1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 （2）改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。主要包括以下几个模块： State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。 Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。 Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。 Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。 Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。 42、使用过 Vue SSR 吗？说说 SSR？ Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。即：SSR大致的意思就是vue在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的html 片段直接返回给客户端这个过程就叫做服务端渲染。 服务端渲染 SSR 的优缺点如下：（1）服务端渲染的优点： 更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面； 更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间； （2) 服务端渲染的缺点： 更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境； 更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。 43、vue-router 路由模式有几种？ vue-router 有 3 种路由模式：hash、history、abstract，对应的源码如下所示： 123456789101112131415switch (mode) &#123; case 'history': this.history = new HTML5History(this, options.base) break case 'hash': this.history = new HashHistory(this, options.base, this.fallback) break case 'abstract': this.history = new AbstractHistory(this, options.base) break default: if (process.env.NODE_ENV !== 'production') &#123; assert(false, `invalid mode: $&#123;mode&#125;`) &#125;&#125; 其中，3 种路由模式的说明如下： hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器； history : 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式； abstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式. 44、能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？ （1）hash 模式的实现原理早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 ‘#search’： 1https://www.word.com#search hash 路由模式的实现主要是基于下面几个特性： URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送； hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换； 可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值； 我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。 （2）history 模式的实现原理HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示： 12window.history.pushState(null, null, path);window.history.replaceState(null, null, path); history 路由模式的实现主要基于存在下面几个特性： pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ； 我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）； history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。 45、什么是 MVVM？ Model–View–ViewModel （MVVM） 是一个软件架构设计模式，由微软 WPF 和 Silverlight 的架构师 Ken Cooper 和 Ted Peters 开发，是一种简化用户界面的事件驱动编程方式。由 John Gossman（同样也是 WPF 和 Silverlight 的架构师）于2005年在他的博客上发表MVVM 源自于经典的 Model–View–Controller（MVC）模式 ，MVVM 的出现促进了前端开发与后端业务逻辑的分离，极大地提高了前端开发效率，MVVM 的核心是 ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。 （1）View 层View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建 。 （2）Model 层 Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。 （3）ViewModel 层 ViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。需要注意的是 ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的，比如页面的这一块展示什么，而页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互），视图状态和行为都封装在了 ViewModel 里。这样的封装使得 ViewModel 可以完整地去描述 View 层。 MVVM 框架实现了双向绑定，这样 ViewModel 的内容会实时展现在 View 层，前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图，MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新。这样 View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。 我们以下通过一个 Vue 实例来说明 MVVM 的具体实现，有 Vue 开发经验的同学应该一目了然：（1）View 层 1234&lt;div id&#x3D;&quot;app&quot;&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;p&gt; &lt;button v-on:click&#x3D;&quot;showMessage()&quot;&gt;Click me&lt;&#x2F;button&gt;&lt;&#x2F;div&gt; （2）ViewModel 层 12345678910111213141516171819202122var app = new Vue(&#123; el: '#app', data: &#123; // 用于描述视图状态 message: 'Hello Vue!', &#125;, methods: &#123; // 用于描述视图行为 showMessage()&#123; let vm = this; alert(vm.message); &#125; &#125;, created()&#123; let vm = this; // Ajax 获取 Model 层的数据 ajax(&#123; url: '/your/server/data/api', success(res)&#123; vm.message = res; &#125; &#125;); &#125;&#125;) （3） Model 层 12345678&#123; \"url\": \"/your/server/data/api\", \"res\": &#123; \"success\": true, \"name\": \"IoveC\", \"domain\": \"www.cnblogs.com\" &#125;&#125; 46、Vue 是如何实现数据双向绑定的？ Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据。 即： 输入框内容变化时，Data 中的数据同步变化。即 View =&gt; Data 的变化。 Data 中的数据变化时，文本节点的内容同步变化。即 Data =&gt; View 的变化。 其中，View 变化更新 Data ，可以通过事件监听的方式来实现，所以 Vue 的数据双向绑定的工作主要是如何根据 Data 变化更新 View。 Vue 主要通过以下 4 个步骤来实现数据双向绑定的： 实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。以上四个步骤的流程图表示如下，如果有同学理解不大清晰的，可以查看作者专门介绍数据双向绑定的文章《0 到 1 掌握：Vue 核心之数据双向绑定》，有进行详细的讲解、以及代码 demo 示例。 47、Vue 框架怎么实现对象和数组的监听？ 如果被问到 Vue 怎么实现数据双向绑定，大家肯定都会回答 通过 Object.defineProperty() 对数据进行劫持，但是 Object.defineProperty() 只能对属性进行数据劫持，不能对整个对象进行劫持，同理无法对数组进行劫持，但是我们在使用 Vue 框架中都知道，Vue 能检测到对象和数组（部分方法的操作）的变化，那它是怎么实现的呢？我们查看相关代码如下： 123456789101112/** * Observe a list of Array items. */observeArray (items: Array&lt;any&gt;) &#123; for (let i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]) // observe 功能为监测数据的变化 &#125;&#125;/** * 对属性进行递归遍历 */let childOb = !shallow &amp;&amp; observe(val) // observe 功能为监测数据的变化 通过以上 Vue 源码部分查看，我们就能知道 Vue 框架是通过遍历数组 和递归遍历对象，从而达到利用 Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听。 48、Proxy 与 Object.defineProperty 优劣对比 Proxy 的优势如下: Proxy 可以直接监听对象而非属性； Proxy 可以直接监听数组的变化； Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的； Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改； Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利； Object.defineProperty 的优势如下: 兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。 Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？ 受现代 JavaScript 的限制 ，Vue 无法检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。但是 Vue 提供了 Vue.set (object, propertyName, value) / vm.$set (object, propertyName, value) 来实现为对象添加响应式属性，那框架本身是如何实现的呢？ 我们查看对应的 Vue 源码：vue/src/core/instance/index.js 12345678910111213141516171819202122232425export function set (target: Array&lt;any&gt; | Object, key: any, val: any): any &#123; &#x2F;&#x2F; target 为数组 if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123; &#x2F;&#x2F; 修改数组的长度, 避免索引&gt;数组长度导致splcie()执行有误 target.length &#x3D; Math.max(target.length, key) &#x2F;&#x2F; 利用数组的splice变异方法触发响应式 target.splice(key, 1, val) return val &#125; &#x2F;&#x2F; key 已经存在，直接修改属性值 if (key in target &amp;&amp; !(key in Object.prototype)) &#123; target[key] &#x3D; val return val &#125; const ob &#x3D; (target: any).__ob__ &#x2F;&#x2F; target 本身就不是响应式数据, 直接赋值 if (!ob) &#123; target[key] &#x3D; val return val &#125; &#x2F;&#x2F; 对属性进行响应式处理 defineReactive(ob.value, key, val) ob.dep.notify() return val&#125; 我们阅读以上源码可知，vm.$set 的实现原理是： 如果目标是数组，直接使用数组的 splice 方法触发相应式； 如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法） 49、虚拟 DOM 的优缺点？ 优点： 保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限； 无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率； 跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。 缺点: 无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。 50、虚拟 DOM 实现原理？ 虚拟 DOM 的实现原理主要包括以下 3 部分： 用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象； diff 算法 — 比较两棵虚拟 DOM 树的差异； pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。 如果对以上 3 个部分还不是很了解的同学，可以查看本文作者写的另一篇详解虚拟 DOM 的文章《深入剖析：Vue核心之虚拟DOM》 51、Vue 中的 key 有什么作用？ key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。Vue 的 diff 过程可以概括为：oldCh 和 newCh 各有两个头尾的变量 oldStartIndex、oldEndIndex 和 newStartIndex、newEndIndex，它们会新节点和旧节点会进行两两对比，即一共有4种比较方式：newStartIndex 和oldStartIndex 、newEndIndex 和 oldEndIndex 、newStartIndex 和 oldEndIndex 、newEndIndex 和 oldStartIndex，如果以上 4 种比较都没匹配，如果设置了key，就会用 key 再进行比较，在比较的过程中，遍历会往中间靠，一旦 StartIdx &gt; EndIdx 表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比较。具体有无 key 的 diff 过程，可以查看作者写的另一篇详解虚拟 DOM 的文章《深入剖析：Vue核心之虚拟DOM》 所以 Vue 中 key 的作用是：key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速 更准确：因为带 key 就不是就地复用了，在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确。更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快，源码如下： 123456789 function createKeyToOldIdx (children, beginIdx, endIdx) &#123; let i, key const map = &#123;&#125; for (i = beginIdx; i &lt;= endIdx; ++i) &#123; key = children[i].key if (isDef(key)) map[key] = i &#125; return map&#125; 52、你有对 Vue 项目进行哪些优化？ 如果没有对 Vue 项目没有进行过优化总结的同学，可以参考本文作者的另一篇文章《 Vue 项目性能优化 — 实践指南 》，文章主要介绍从 3 个大方面，22 个小方面详细讲解如何进行 Vue 项目的优化。（1）代码层面的优化 v-if 和 v-show 区分使用场景 computed 和 watch 区分使用场景 v-for 遍历必须为 item 添加 key，且避免同时使用 v-if 长列表性能优化 事件的销毁 图片资源懒加载 路由懒加载 第三方插件的按需引入 优化无限列表性能 服务端渲染 SSR or 预渲染 （2）Webpack 层面的优化 Webpack 对图片进行压缩 减少 ES6 转为 ES5 的冗余代码 提取公共代码 模板预编译 提取组件的 CSS 优化 SourceMap 构建结果输出分析 Vue 项目的编译优化 （3）基础的 Web 技术的优化 开启 gzip 压缩 浏览器缓存 CDN 的使用 使用 Chrome Performance 查找性能瓶颈 53、对于即将到来的 vue3.0 特性你有什么了解的吗？ Vue 3.0 正走在发布的路上，Vue 3.0 的目标是让 Vue 核心变得更小、更快、更强大，因此 Vue 3.0 增加以下这些新特性： （1）监测机制的改变 3.0 将带来基于代理 Proxy 的 observer 实现，提供全语言覆盖的反应性跟踪。这消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制： 只能监测属性，不能监测对象 检测属性的添加和删除； 检测数组索引和长度的变更； 支持 Map、Set、WeakMap 和 WeakSet。 新的 observer 还提供了以下特性： 用于创建 observable 的公开 API。这为中小规模场景提供了简单轻量级的跨组件状态管理解决方案。 默认采用惰性观察。在 2.x 中，不管反应式数据有多大，都会在启动时被观察到。如果你的数据集很大，这可能会在应用启动时带来明显的开销。在 3.x 中，只观察用于渲染应用程序最初可见部分的数据。 更精确的变更通知。在 2.x 中，通过 Vue.set 强制添加新属性将导致依赖于该对象的 watcher 收到变更通知。在 3.x 中，只有依赖于特定属性的 watcher 才会收到通知。 不可变的 observable：我们可以创建值的“不可变”版本（即使是嵌套属性），除非系统在内部暂时将其“解禁”。这个机制可用于冻结 prop 传递或 Vuex 状态树以外的变化。 更好的调试功能：我们可以使用新的 renderTracked 和 renderTriggered 钩子精确地跟踪组件在什么时候以及为什么重新渲染。 （2）模板 模板方面没有大的变更，只改了作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。 （3）对象式的组件声明方式 vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易。此外，vue 的源码也改用了 TypeScript 来写。其实当代码的功能复杂之后，必须有一个静态类型系统来做一些辅助管理。现在 vue3.0 也全面改用 TypeScript 来重写了，更是使得对外暴露的 api 更容易结合 TypeScript。静态类型系统对于复杂代码的维护确实很有必要。 （4）其它方面的更改 vue3.0 的改变是全面的，上面只涉及到主要的 3 个方面，还有一些其他的更改： 支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。 支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。 基于 treeshaking 优化，提供了更多的内置功能。 54、完整的 vue-router 导航解析流程 1.导航被触发；2.在失活的组件里调用beforeRouteLeave守卫；3.调用全局beforeEach守卫；4.在复用组件里调用beforeRouteUpdate守卫；5.调用路由配置里的beforeEnter守卫；6.解析异步路由组件；7.在被激活的组件里调用beforeRouteEnter守卫；8.调用全局beforeResolve守卫；9.导航被确认；10..调用全局的afterEach钩子；11.DOM更新；12.用创建好的实例调用beforeRouteEnter守卫中传给next的回调函数。 参考资料 知乎专栏 知乎专栏——活泼的小白洋","categories":[{"name":"前端","slug":"前端","permalink":"http://arthurwang.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"前端/Vue","permalink":"http://arthurwang.top/categories/%E5%89%8D%E7%AB%AF/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://arthurwang.top/tags/Vue/"}]},{"title":"一个基于 vue + elementUI 的后台管理系统","slug":"vue-cms","date":"2020-03-30T03:59:07.000Z","updated":"2020-03-30T08:07:44.879Z","comments":true,"path":"2020/03/30/vue-cms/","link":"","permalink":"http://arthurwang.top/2020/03/30/vue-cms/","excerpt":"","text":"项目概述 电商后台管理系统整体采用前后端分离的开发模式，其中前端项目是基于 Vue 技术栈的 SPA 项目。 技术选型： Vue Vue-router Element-UI Axios Echarts 登录/登出功能登录功能登录实现axios请求登录API 12345678const &#123; data: res &#125; = await this.$http.post('login', this.loginForm) if (res.meta.status !== 200) return this.$message.error('登录失败!') // 提示登录成功this.$message.success('登录成功!')// 把登录成功的token保存到sessionStorage window.sessionStorage.setItem('token', res.data.token) // 使用编程式导航，跳转到后台主页 this.$router.push('/home') 路由导航守卫控制访问权限如果用户没有登录，但是直接通过 URL 访问特定页面，需要重新导航到登录页面。 导航守卫官方文档 12345678910// 为路由对象，添加 beforeEach 导航守卫 router.beforeEach((to, from, next) =&gt; &#123; // 如果用户访问的登录页，直接放行 if (to.path === '/login') return next() // 从 sessionStorage 中获取到 保存的 token 值 const tokenStr = window.sessionStorage.getItem('token') // 没有token，强制跳转到登录页 if (!tokenStr) return next('/login') next()&#125;) 表单验证12345// 进行表单验证 this.$refs.loginFormRef.validate(async valid =&gt; &#123;// 如果验证失败，直接退出后续代码的执行if (!valid) return// 验证通过后这里完成登录成功后的相关操作(保存token、跳转到主页)&#125;) 退出功能基于 token 的方式实现退出比较简单，只需要销毁本地的 token 即可。这样，后续的请求就不会携带 token ， 必须重新登录生成一个新的 token 之后才可以访问页面。 1234// 清空token window.sessionStorage.clear() // 跳转到登录页 this.$router.push('/login') 主页主页布局先上下，后左右 12345678910&lt;el-container&gt; &lt;!-- 头部区域 --&gt; &lt;el-header&gt;&lt;&#x2F;el-header&gt; &lt;el-container&gt; &lt;!-- 侧边栏区域 --&gt; &lt;el-aside&gt;&lt;&#x2F;el-aside&gt; &lt;!-- 右侧主体区域 --&gt; &lt;el-main&gt;&lt;&#x2F;el-main&gt; &lt;&#x2F;el-container&gt; &lt;&#x2F;el-container&gt; 通过接口获取菜单数据通过 axios 请求拦截器添加 token，保证拥有获取数据的权限。 123456// axios请求拦截 axios.interceptors.request.use(config =&gt; &#123; // 为请求头对象，添加 Token 验证的 Authorization 字段 config.headers.Authorization = window.sessionStorage.getItem('token') return config&#125;) 动态渲染菜单数据并进行路由控制 通过 v-for 双层循环分别进行一级菜单和二级菜单的渲染 通过路由相关属性(router)启用菜单的路由功能 用户管理 通过后台管理用户的账号信息，具体包括用户信息的展示、添加、修改、删除、角色分配、账号启用/注销等功能。 布局 面包屑导航el-breadcrumb Element-UI栅格系统基本使用el-row 表格布局el-table、el-pagination 用户状态列作用域插槽 1234567&lt;template slot-scope&#x3D;&quot;scope&quot;&gt; &lt;!-- 开关 --&gt; &lt;el-switch v-model&#x3D;&quot;scope.row.mg_state&quot; @change&#x3D;&quot;stateChanged(scope.row.id, scope.row.mg_state)&quot; &gt;&lt;&#x2F;el-switch&gt;&lt;&#x2F;template&gt; 数据分页 当前页码:pagenum 每页条数:pagesize 记录总数:total 页码变化事件 每页条数变化事件 分页条菜单控制 12345678910&lt;el-pagination @size-change&#x3D;&quot;handleSizeChange&quot; @current-change&#x3D;&quot;handleCurrentChange&quot; :current-page&#x3D;&quot;queryInfo.pagenum&quot; :page-sizes&#x3D;&quot;[2, 3, 5, 10]&quot; :page-size&#x3D;&quot;queryInfo.pagesize&quot; layout&#x3D;&quot;total, sizes, prev, pager, next, jumper&quot; :total&#x3D;&quot;total&quot;&gt;&lt;&#x2F;el-pagination&gt; 自定义表单验证规则（手机号）1234567891011const checkMobile = (rule, value, cb) =&gt; &#123; let reg = /^(0|86|17951)?(13[0-9]|15[012356789]|17[678]|18[0-9]|14[57])[0-9]&#123;8&#125;$/ if (reg.test(value)) &#123; cb() &#125; else &#123; cb(new Error('手机号码格式不正确')) &#125; &#125;mobile: [ &#123; required: true, message: '请输入手机号', trigger: 'blur' &#125;, &#123; validator: checkMobile, trigger: 'blur' &#125;] 权限管理 通过权限管理模块控制不同的用户可以进行哪些操作，具体可以通过角色的方式进行控制，即每个用户分配 一个特定的角色，角色包括不同的功能权限。 角色权限分配展开行通过 el-table-column 组件的 type =“expand” 方式实现表格行展开效果 分类管理树形表格vue-table-with-tree-grid 1npm i vue-table-with-tree-grid -S 123import Vue from 'vue'import ZkTable from 'vue-table-with-tree-grid' Vue.use(ZkTable) 商品管理添加商品商品详情富文本编辑器： 12// 安装vue-quill-editornpm install vue-quill-editor -S 12import VueQuillEditor from 'vue-quill-editor'Vue.use(VueQuillEditor) 1&lt;quill-editor v-model&#x3D;&quot;addForm.goods_introduce&quot;&gt;&lt;&#x2F;quill-editor&gt; 数据统计安装echarts12// 安装echarts库npm install echarts -S 12// 导入echarts接口import echarts from 'echarts' 绘制1234567// 基于准备好的dom，初始化echarts实例var myChart = echarts.init(this.$refs.main)const &#123; data: res &#125; = await this.$http.get('reports/type/1')if (res.meta.status !== 200) return this.$message.error('初始化折线图失败!') const data = _.merge(res.data, this.options)// 绘制图表myChart.setOption(data)","categories":[{"name":"前端","slug":"前端","permalink":"http://arthurwang.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"前端/Vue","permalink":"http://arthurwang.top/categories/%E5%89%8D%E7%AB%AF/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://arthurwang.top/tags/Vue/"}]},{"title":"webpack4.x 安装postcss-loader 配合 autoprefixer 解决css3的兼容性","slug":"webpack-autoprefixer","date":"2020-02-26T10:40:57.000Z","updated":"2020-02-27T06:51:07.000Z","comments":true,"path":"2020/02/26/webpack-autoprefixer/","link":"","permalink":"http://arthurwang.top/2020/02/26/webpack-autoprefixer/","excerpt":"","text":"安装浏览器前缀需要 post-loader、autoprefixer 1cnpm install --save-dev css-loader style-loader postcss-loader autoprefixer 配置webpack.config.js12345678910111213&#123; test:&#x2F;\\.css$&#x2F;, use:[ &#123;loader:&#39;style-loader&#39;&#125;, &#123; loader:&#39;css-loader&#39;, options:&#123; importLoaders:1 &#125; &#125;, &#123;loader:&#39;postcss-loader&#39;&#125; ]&#125; 根目录创建postcss.config.js在项目根目录创建 postcss.config.js，并且设置支持哪些浏览器，必须设置支持的浏览器才会自动添加添加浏览器兼容 1234567891011121314module.exports &#x3D; &#123; plugins: [ require(&#39;autoprefixer&#39;)(&#123; &quot;browsers&quot;: [ &quot;defaults&quot;, &quot;not ie &lt; 11&quot;, &quot;last 2 versions&quot;, &quot;&gt; 1%&quot;, &quot;iOS 7&quot;, &quot;last 3 iOS versions&quot; ] &#125;) ]&#125;;","categories":[{"name":"工程化","slug":"工程化","permalink":"http://arthurwang.top/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"webpack","slug":"工程化/webpack","permalink":"http://arthurwang.top/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://arthurwang.top/tags/webpack/"}]},{"title":"一个文章电影类小程序","slug":"project-miniprogram-douban","date":"2020-02-22T10:52:19.000Z","updated":"2020-02-27T06:51:10.000Z","comments":true,"path":"2020/02/22/project-miniprogram-douban/","link":"","permalink":"http://arthurwang.top/2020/02/22/project-miniprogram-douban/","excerpt":"","text":"本文记录一个基于微信小程序开发的文章和电影资讯类小程序 准备代码结构： 123456789101112article&amp;movie|---welcome &#x2F;&#x2F;启动页|---posts &#x2F;&#x2F;文章页主页 |---post-detail &#x2F;&#x2F;文章详情页 |---posts-template &#x2F;&#x2F;文章主页模板文件|---movies &#x2F;&#x2F;电影主页 |---movie-list &#x2F;&#x2F;电影列表模板文件 |---movie-item &#x2F;&#x2F;电影列表项模板文件 |---movie-detail &#x2F;&#x2F;电影详情页 |---stars &#x2F;&#x2F;评分星级模板文件 |---movie-more &#x2F;&#x2F;更多电影页 |---template-movie-gird &#x2F;&#x2F;电影网格模板文件 说明：文章页数据来自本地，电影信息从豆瓣API获取。 welcome启动页目的是初识小程序，略微熟悉小程序代码。 通过 welcom 启动页 「开启小程序之旅」 按钮点击进入 posts 文章页： 123&lt;view class&#x3D;&quot;user-start&quot; bindtap&#x3D;&quot;onBtnTap&quot;&gt; &lt;text class&#x3D;&quot;start-btn&quot;&gt;开启小程序之旅&lt;&#x2F;text&gt;&lt;&#x2F;view&gt; 值得注意的是，如果想要路由到tab栏中的某一页，必须使用 wx.switchTab，而 wx.navigateTo 和 wx.redirectTo 均不可用： 12345onBtnTap: function() &#123; wx.switchTab(&#123; url: &#39;..&#x2F;posts&#x2F;posts&#39;, &#125;)&#125; posts文章页文章页轮播图小程序中轮播图可用自带的 swiper 组件来实现： 1234567891011&lt;swiper catchtap&#x3D;&quot;onSwiperTap&quot; autoplay&#x3D;&quot;true&quot; indicator-dots&#x3D;&quot;true&quot;&gt; &lt;swiper-item&gt; &lt;image src&#x3D;&quot;&#x2F;images&#x2F;vr.png&quot; data-postId&#x3D;&quot;0004&quot;&gt;&lt;&#x2F;image&gt; &lt;&#x2F;swiper-item&gt; &lt;swiper-item&gt; &lt;image src&#x3D;&quot;&#x2F;images&#x2F;wx.png&quot; data-postId&#x3D;&quot;0003&quot;&gt;&lt;&#x2F;image&gt; &lt;&#x2F;swiper-item&gt; &lt;swiper-item&gt; &lt;image src&#x3D;&quot;&#x2F;images&#x2F;iqiyi.png&quot; data-postId&#x3D;&quot;0005&quot;&gt;&lt;&#x2F;image&gt; &lt;&#x2F;swiper-item&gt;&lt;&#x2F;swiper&gt; 点击路由到相应的文章详情页： 123456onSwiperTap: function (event) &#123; var postId &#x3D; event.target.dataset.postid; &#x2F;&#x2F;点击获取元素上绑定的postid wx.navigateTo(&#123; url: &#39;post-detail&#x2F;post-detail?id&#x3D;&#39; + postId, &#125;)&#125;, posts_template使用模板可以更好的实现代码复用，提高开发效率。 模板文件中： 1&lt;template name&#x3D;&quot;post-item&quot;&gt;xxx&lt;&#x2F;template&gt; 使用模板： 12&lt;import src&#x3D;&quot;posts_template&#x2F;posts_template &#x2F;&gt;&lt;template is&#x3D;&quot;post-item&quot;&gt;&lt;&#x2F;template&gt; 注意要在 wxss 文件中引入模板的样式： 1@import &quot;posts_template&#x2F;posts_template&quot;; template没有 js 和 json 文件，所以逻辑要写到引用的文件里。 文章详情页通过 onLoad 函数传的 options 获取路由中的 id ，遍历获得相应的文章数据： 1234567var postId &#x3D; options.id;var postList &#x3D; postsData.postList; &#x2F;&#x2F;postsData为本地数据postList.forEach(item &#x3D;&gt; &#123; if(item.postId &#x3D;&#x3D;&#x3D; postId) &#123; this.setData(&#123; postItem: item &#125;); &#125;&#125;) 文章收藏模块文章页没有与服务器通信，所以用本地存储来做收藏状态的纪录。 页面 onLoad 的时候从本地存储拿 post_collected，存在的话拿到文章是否收藏的状态，不存在的话给文章的收藏状态设为 false： 12345678910111213var postCollected &#x3D; wx.getStorageSync(&#39;post_collected&#39;);if(postCollected)&#123; var pageCollected &#x3D; postCollected[postId]; if(pageCollected) &#123; this.setData(&#123;collected: pageCollected&#125;); &#125; else &#123; postCollected[postId] &#x3D; false; wx.setStorageSync(&#39;post_collected&#39;, postCollected);&#125; else &#123; var postCollected &#x3D; &#123;&#125;; postCollected[postId] &#x3D; false; wx.setStorageSync(&#39;post_collected&#39;, postCollected);&#125; 点击收藏按钮： 1234567891011onCollectTap: function() &#123; var postCollected &#x3D; wx.getStorageSync(&#39;post_collected&#39;); postCollected[this.data.postId] &#x3D; !postCollected[this.data.postId]; this.setData(&#123;collected: postCollected[this.data.postId]&#125;); wx.setStorageSync(&#39;post_collected&#39;, postCollected); &#x2F;&#x2F;收藏成功与取消收藏成功弹窗 wx.showToast(&#123; title: postsCollected[this.data.postId] ? &#39;收藏成功&#39; : &#39;取消成功&#39;, duration: 1000 &#125;);&#125; 页面通过判断 collected 来决定显示收藏图片。 12&lt;image wx:if&#x3D;&quot;&#123;&#123;collected&#125;&#125;&quot; class&#x3D;&quot;detail-collect&quot; catchtap&#x3D;&quot;onCollectTap&quot; src&#x3D;&quot;&#x2F;images&#x2F;icon&#x2F;collection.png&quot;&gt;&lt;&#x2F;image&gt;&lt;image wx:else class&#x3D;&quot;detail-collect&quot; catchtap&#x3D;&quot;onCollectTap&quot; src&#x3D;&quot;&#x2F;images&#x2F;icon&#x2F;collection-anti.png&quot;&gt;&lt;&#x2F;image&gt; 背景音乐模块初始化一个音乐播放器： 12345678910initMusicPlayer: function() &#123; const backgroundAudioManager &#x3D; wx.getBackgroundAudioManager(); const music &#x3D; this.data.postItem.music; backgroundAudioManager.title &#x3D; music.title; backgroundAudioManager.singer &#x3D; music.singer; backgroundAudioManager.coverImgUrl &#x3D; music.coverImgUrl; &#x2F;&#x2F; 设置了 src 之后会自动播放 backgroundAudioManager.src &#x3D; music.url; return backgroundAudioManager;&#125; 监控播放器状态可用 onPause 和 onPlay 以及 onEnded。 movies电影页电影数据来自豆瓣API，目前豆瓣已经无法调用，所以选择了其他的源：豆瓣API 电影页大量使用 template 模板实现代码复用。 电影页首页模板嵌套： movie-list -&gt; movie-item -&gt; star 电影页重点是数据的请求与处理: 123456789101112131415&#x2F;&#x2F;在util.js中封装一个发送网络请求函数function _http(url, callback) &#123; wx.request(&#123; url: url, method: &#39;GET&#39;, header: &#123; &#39;content-type&#39;: &#39;json&#39; &#125;, success: function (res) &#123; if (res.data) &#123; callback(res.data) &#125; &#125; &#125;)&#125; 在 movie.js 中只需调用即可： 1234567891011121314151617var top250Url &#x3D; app.globalData.doubanDataUrl + &#39;&#x2F;v2&#x2F;movie&#x2F;top250?start&#x3D;0&amp;&amp;count&#x3D;3&#39;;this.getMovieData(top250Url, &#39;top250&#39;);getMovieData: function(url, sectionType) &#123; var _this &#x3D; this; wx.request(&#123; url: url, method: &#39;GET&#39;, header: &#123; &#39;content-type&#39;: &#39;json&#39; &#125;, success: function(res) &#123; if (res.data) &#123; _this.processDoubanData(res.data, sectionType); &#125; &#125; &#125;)&#125;, processDoubanData 为成功后数据处理函数，主要获取电影的一些信息。 通过 setData 在页面中获取，一层一层往模板里传递即可。 onMoreTap：点击更多跳转到 movie-more 页面; onMovieTap：点击电影跳转电影详情页 movie-detail; 更多电影页引入 template-movie-grid 模板，进入到相应的页面后，通过点击更多传过来的 sectionType 来判断是哪个 更多 按钮进来的，日然后通过 options.sectionType 来发起不同的网络请求拿到对应的数据进行页面渲染： 页面实现的有下拉刷新和上拉加载，可通过小程序自带的 onPullDownRefresh 和 onReachBottom 处理函数实现： 123456789&#x2F;&#x2F;页面相关事件处理函数--监听用户下拉动作onPullDownRefresh: function()&#123; var refreshUrl &#x3D; this.data.requestUrl + &#39;?start&#x3D;0&amp;&amp;count&#x3D;20&#39;; this.data.movieLists &#x3D; &#123;&#125;; this.data.isFirstLoad &#x3D; true; &#x2F;&#x2F;判断是否为第一次加载，第一次加载20条，非第一次加载拼接之前的数据 this.data.totalCount &#x3D; 0; &#x2F;&#x2F;总条目数清零 util._http(refreshUrl, this.processDoubanData); wx.showNavigationBarLoading(); &#x2F;&#x2F;在当前页面显示导航条加载动画&#125; 12345678910111213&#x2F;&#x2F;页面上拉触底事件的处理函数onReachBottom: funtion() &#123; if(this.data.totalCount &gt; this.data.pageCount) &#123; var moreUrl &#x3D; this.data.requestUrl + &quot;?start&#x3D;&quot; + this.data.pageCount + &quot;&amp;&amp;count&#x3D;20&quot;; &#x2F;&#x2F;触底上拉请求20条数据 util._http(moreUrl, this.processDoubanData); wx.showNavigationBarLoading(); &#125; else &#123; wx.showToast(&#123; title: &#39;没有更多数据&#39;, icon: &#39;none&#39; &#125;) &#125;&#125; 电影详情页通过路由带的参数发特定的请求取到电影详情： 12var detailUrl &#x3D; app.globalData.doubanDataUrl + &#39;&#x2F;v2&#x2F;movie&#x2F;subject&#x2F;&#39; + movieId;util._http(detailUrl, this.processDetailData); 点击图片预览大图： 1234var postUrl &#x3D; event.currentTarget.dataset.poster;wx.previewImage(&#123; urls: [postUrl],&#125;) 评分转星级12345678910111213&#x2F;&#x2F;豆瓣电影评分转星级function ratingToStar(rating) &#123; var rating &#x3D; rating.toString().substring(0,1); var starArr &#x3D; [] for(var i&#x3D;1; i&lt;&#x3D;5; i++) &#123; if(i&lt;&#x3D;rating) &#123; starArr.push(1); &#125;else&#123; starArr.push(0); &#125; &#125; return starArr;&#125; 结果为一个五位数组，例如：[1, 1, 1, 0, 0]，1代表全星，0代表无星，如果需要半星，只需再加一个数字进行表示，在 wxml 中进行判断即可。 1234&lt;block wx:for&#x3D;&quot;&#123;&#123;stars&#125;&#125;&quot; wx:key&#x3D;&quot;item&quot;&gt; &lt;image wx:if&#x3D;&quot;&#123;&#123;item&#125;&#125;&quot; src&#x3D;&quot;&#x2F;images&#x2F;icon&#x2F;star.png&quot;&gt;&lt;&#x2F;image&gt; &lt;image wx:else src&#x3D;&quot;&#x2F;images&#x2F;icon&#x2F;none-star.png&quot;&gt;&lt;&#x2F;image&gt;&lt;&#x2F;block&gt; 电影搜索由于搜索接口不能调，所以用了一个不太好使的接口，时常出问题。大致思路是获取到 input 框的值，然后拼接成 url 发送请求。 12345onSearchConfirm:function(event) &#123; var searchTxt &#x3D; event.detail.value; var searchUrl &#x3D; app.globalData.searchDoubanDataUrl + &#39;&#x2F;v2&#x2F;movie&#x2F;search?q&#x3D;&#39; + searchTxt; this.getMovieData(searchUrl, &#39;search&#39;);&#125;,","categories":[{"name":"前端","slug":"前端","permalink":"http://arthurwang.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"小程序","slug":"前端/小程序","permalink":"http://arthurwang.top/categories/%E5%89%8D%E7%AB%AF/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://arthurwang.top/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"项目","slug":"项目","permalink":"http://arthurwang.top/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"一个基于Vue的旅行App","slug":"project-qunar","date":"2020-02-10T17:33:46.000Z","updated":"2020-02-11T14:47:17.000Z","comments":true,"path":"2020/02/11/project-qunar/","link":"","permalink":"http://arthurwang.top/2020/02/11/project-qunar/","excerpt":"","text":"本文记录一个基于Vue开发的旅行app 准备 Axios: Ajax数据获取 Vue Router: 多页面之间的路由 Vuex: 各个组件之间数据共享 异步组件: 代码上线性能更优 Stylus: 样式 递归组件: 组件调用自身 插件: swiper better-scroll 公用组件: 公用组件拆分 代码结构： 12345678910111213141516travel|---Home |---Header |---Swiper |---Icons |---Recommend |---Weekend|---City |---CityHeader |---CitySearch |---CityList |---CityAlphabet|---Detail |---DetailHeader |---DetailBanner |---DetailList Home页面Header组件主要是城市选择功能，点击路由到 city 页面 123456&lt;router-link to&#x3D;&quot;&#x2F;city&quot;&gt; &lt;div class&#x3D;&quot;header-right&quot;&gt; &#123;&#123;this.city&#125;&#125; &lt;span class&#x3D;&quot;iconfont icon-arrow-down&quot;&gt;&amp;#xe64a;&lt;&#x2F;span&gt; &lt;&#x2F;div&gt;&lt;&#x2F;router-link&gt; 其中 this.city 是Vuex提供的当前城市 1...mapState([&#39;city&#39;]) Swiper组件vue-awesome-swiper借助 vue-awesome-swiper 插件实现首页轮播图效果 12345678&lt;div class&#x3D;&quot;swiper-wrapper&quot;&gt; &lt;swiper :options&#x3D;&quot;swiperOption&quot; v-if&#x3D;&quot;showSwiper&quot;&gt; &lt;swiper-slide v-for&#x3D;&quot;item of swiperList&quot; :key&#x3D;&quot;item.id&quot;&gt; &lt;img class&#x3D;&quot;swiper-img&quot; :src&#x3D;&quot;item.imgUrl&quot; alt&#x3D;&quot;&quot;&gt; &lt;&#x2F;swiper-slide&gt; &lt;div class&#x3D;&quot;swiper-pagination&quot; slot&#x3D;&quot;pagination&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;swiper&gt;&lt;&#x2F;div&gt; swiper相关的设置可以在 data 里的 swiperOption 里配置 1234567swiperOption: &#123; autoplay: true, loop: true, pagination: &#123; el: &#39;.swiper-pagination&#39; &#125;&#125; 轮播图片通过ajax动态获取，接收从 Home.vue 传的 swiperList 数组。 使用 &gt;&gt;&gt; 穿透scoped其中分页器需要把颜色调成白色： 12.swiper-wrapper &gt;&gt;&gt; .swiper-pagination-bullet-active background #ffffff !important 这里用到了 &gt;&gt;&gt; 来穿透scoped vue引用了第三方组件，需要在组件中局部修改第三方组件的样式，而又不想去除scoped属性造成组件之间的样式污染。此时只能通过 &gt;&gt;&gt;，穿透scoped。 有些 Sass 之类的预处理器无法正确解析 &gt;&gt;&gt;。可以使用 /deep/ 操作符( &gt;&gt;&gt; 的别名) 12345678&lt;style scoped&gt; 外层 &gt;&gt;&gt; 第三方组件 &#123; 样式 &#125;&#x2F;deep&#x2F; 第三方组件 &#123; 样式&#125;&lt;&#x2F;style&gt; Icons组件重点是一个页面8个icon区域，从 Home.vue 拿 iconList 数据，超出8个就要进行分页，同时利用 swiper 实现左右滑动。 拿到 iconList 后对数据进行拆分，形成一个二维数组： 12345678910111213computed: &#123; pages () &#123; const pages &#x3D; [] this.iconList.forEach((item, index) &#x3D;&gt; &#123; const page &#x3D; Math.floor(index &#x2F; 8) if (!pages[page]) &#123; pages[page] &#x3D; [] &#125; pages[page].push(item) &#125;) return pages &#125;&#125; 数据循环渲染： 123456789101112&lt;div class&#x3D;&quot;icons-wrapper&quot;&gt; &lt;swiper&gt; &lt;swiper-slide v-for&#x3D;&quot;(page, index) in pages&quot; :key&#x3D;&quot;index&quot;&gt; &lt;div class&#x3D;&quot;icon&quot; v-for&#x3D;&quot;item in page&quot; :key&#x3D;&quot;item.id&quot;&gt; &lt;div class&#x3D;&quot;icon-img&quot;&gt; &lt;img class&#x3D;&quot;icon-img-content&quot; :src&#x3D;&quot;item.imgUrl&quot; alt&#x3D;&quot;&quot;&gt; &lt;&#x2F;div&gt; &lt;p class&#x3D;&quot;icon-desc&quot;&gt;&#123;&#123;item.desc&#125;&#125;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt; &lt;&#x2F;swiper-slide&gt; &lt;&#x2F;swiper&gt;&lt;&#x2F;div&gt; 首先在 swiper-slide 上对 pages 进行循环，然后在内部的图片和文字描述上对上层循环的 page 进行循环，以此来实现分页。 Recommed组件 Weekend组件组件唯一重点是动态路由，跳转到详情页的时候带一个参数 id： 123&lt;router-link :to&#x3D;&quot;&#39;&#x2F;detail&#x2F;&#39;+item.id&quot;&gt; &#x2F;&#x2F;内容&lt;&#x2F;router-link&gt; 12345const routes &#x3D; [&#123; name: &#39;&#x2F;detail&#x2F;:id&#39;, name: &#39;detail&#39;, component: Detail&#125;] 在详情页组件 Detail.vue 中发送ajax请求时，也要带一个参数： 1234567getDetailInfo () &#123; axios.get(&#39;&#x2F;mock&#x2F;details.json&#39;, &#123; params: &#123; id: this.$route.params.id &#125; &#125;).then(this.getDetailInfoSucc)&#125; City页面CityHeader组件无特殊说明 CityList组件城市列表组件，数据是从 City.vue 传过来的 cities 和 hotCities，页面滚动使用 better-scroll 插件来到近似原生APP的效果，同时也为了实现点击字母滚动到相应的部分。 123mounted () &#123; this.scroll &#x3D; new BScroll(this.$refs.wrapper, &#123;&#125;)&#125; 城市列表部分对 cities 进行两次循环： 12345678910111213141516&lt;div class&#x3D;&quot;area&quot; v-for&#x3D;&quot;(item, key) in cities&quot; :key&#x3D;&quot;key&quot; :ref&#x3D;&quot;key&quot;&gt; &lt;div class&#x3D;&quot;city-title&quot;&gt;&#123;&#123;key&#125;&#125;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;city-alphbet-list&quot;&gt; &lt;div class&#x3D;&quot;city-alphbet-item border-topbottom&quot; v-for&#x3D;&quot;innerItem in item&quot; :key&#x3D;&quot;innerItem.id&quot; @click&#x3D;&quot;handleCityClick(innerItem.name)&quot; &gt; &#123;&#123;innerItem.name&#125;&#125; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;&#x2F;div&gt; 外层 .area 循环开头字母，内层 .city-alphabet-item 循环城市名。 对于和字母组件联动实现点击字母跳转到相应的部分，需要先在 CityAlphabet.vue 里获取点击的字母，通过 $emit 传给他们共同的父组件 City.vue，然后在传给 CityList.vue，拿到字母 letter 后进行监听，通过 better-scorll 滚动到相应的区域： 12345678watch: &#123; letter () &#123; if (this.letter) &#123; const ele &#x3D; this.$refs[this.letter][0] this.scroll.scrollToElement(ele) &#125; &#125;&#125; 点击城市名可以实现城市改变，同时跳转到首页： 1234567methods: &#123; handleCityClick (city) &#123; this.cityChange(city) this.$router.push(&#39;&#x2F;&#39;) &#125;, ...mapMutations([&#39;cityChange&#39;])&#125; CityAlphabet组件字母列表循环 cities 里的 key： 12345678910111213&lt;ul class&#x3D;&quot;alphabet-list&quot;&gt; &lt;li class&#x3D;&quot;alphabet-item&quot; v-for&#x3D;&quot;(item, key) in cities&quot; :key&#x3D;&quot;key&quot; :ref&#x3D;&quot;key&quot; @click&#x3D;&quot;handleLetterClick&quot; @touchstart&#x3D;&quot;handleTouchStart&quot; @touchmove&#x3D;&quot;handleTouchMove&quot; @touchend&#x3D;&quot;handleTouchend&quot; &gt; &#123;&#123;key&#125;&#125; &lt;&#x2F;li&gt;&lt;&#x2F;ul&gt; 点击事件向父组件传递点击对应的字母： 123handleLetterClick (e) &#123; this.$emit(&#39;letterChange&#39;, e.target.innerText)&#125; 触摸状态 touchStatus 初始为 false，触摸滚动开始为true，触摸滚动结束为false。通过计算触摸当前距顶部距离计算当前字母： 1234567891011121314151617181920handleTouchStart () &#123; this.touchStatus &#x3D; true&#125;,handleTouchMove (e) &#123; if (this.touchStatus) &#123; if (this.timer) &#123; clearTimeout(this.timer) &#125; this.timer &#x3D; setTimeout(() &#x3D;&gt; &#123; const touchY &#x3D; e.touches[0].clientY - 79 const index &#x3D; Math.floor((touchY - this.startY) &#x2F; 20) if (index &gt;&#x3D; 0 &amp;&amp; index &lt; this.letters.length) &#123; this.$emit(&#39;letterChange&#39;, this.letters[index]) &#125; &#125;, 7) &#125;&#125;,handleTouchend () &#123; this.touchStatus &#x3D; false&#125; this.startY 是 A 距离顶部的距离： 1this.startY &#x3D; this.$refs[&#39;A&#39;][0].offsetTop CitySearch组件给 input 的 v-model 设置一个 keyword， 对 keyword 进行监听： 12345678910111213141516171819202122watch: &#123; keyword () &#123; if (this.timer) &#123; clearTimeout(this.timer) &#125; if (!this.keyword) &#123; this.list &#x3D; [] return &#125; this.timer &#x3D; setTimeout(() &#x3D;&gt; &#123; const result &#x3D; [] for (let i in this.cities) &#123; this.cities[i].forEach((value) &#x3D;&gt; &#123; if (value.spell.indexOf(this.keyword) &gt; -1 || value.name.indexOf(this.keyword) &gt; -1) &#123; result.push(value) &#125; &#125;) &#125; this.list &#x3D; result &#125;, 100) &#125;&#125; 对从 City.vue 传过来的 cities 数据进行 forEach 遍历，如果存在拼写名 value.spell 或 城市名 value.name 和 keyword 有匹配，就把当前数据添加到 result 里，并且也页面中循环这个数据。同样点击城市后可以修改 vuex 中的数据，实现城市之间的切换。 页面滚动同样使用 better-scroll，同时使用定时器来提高页面性能。 Detail页面DetailHeader组件动态绑定属性实现向下滚动时头部有透明度渐隐渐现效果 DetailBanner组件通过公用组件 Gallery.vue 来实现画廊效果， FadeAnimation.vue 来实现画廊组件的渐隐渐现。 1234567&lt;fade-animation&gt; &lt;common-gallery v-if&#x3D;&quot;showGallery&quot; :images&#x3D;&quot;galleryImgs&quot; @close&#x3D;&quot;galleryClose&quot; &gt;&lt;&#x2F;common-gallery&gt;&lt;&#x2F;fade-animation&gt; DetailList组件递归组件 ，自身调用自身 123&lt;div v-if&#x3D;&quot;item.children&quot; class&#x3D;&quot;item-children&quot;&gt; &lt;detail-list :detailList&#x3D;&quot;item.children&quot;&gt;&lt;&#x2F;detail-list&gt;&lt;&#x2F;div&gt; 公用组件FadeAnimationtransition 实现渐隐渐现 Gallery画廊组件，通过 swiper 实现 图标采用了 Iconfont-阿里巴巴矢量图标库 页面：","categories":[{"name":"前端","slug":"前端","permalink":"http://arthurwang.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"前端/Vue","permalink":"http://arthurwang.top/categories/%E5%89%8D%E7%AB%AF/Vue/"}],"tags":[{"name":"项目","slug":"项目","permalink":"http://arthurwang.top/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"前端","slug":"前端","permalink":"http://arthurwang.top/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"vue中router与route","slug":"vue-router-route","date":"2020-02-10T15:28:27.000Z","updated":"2020-02-10T17:10:47.000Z","comments":true,"path":"2020/02/10/vue-router-route/","link":"","permalink":"http://arthurwang.top/2020/02/10/vue-router-route/","excerpt":"","text":"router$router 对象是全局路由的实例，是 router 构造方法的实例，主要是实现路由跳转。 路由实例方法： 一、 push 1、字符串 this.router.push(′home′)2、对象 this.router.push({ path: &#39;home&#39; })3、命名的路由 this.router.push(name:′user′,params:userId:123)4、带查询参数 /register?plan=123，变成 this. router.push({name:&#39;user&#39;,params:{userId:123}}) push 方法其实和 &lt;router-link :to=&quot;…&quot;&gt; 是等同的。 注意：push 方法的跳转会向 history 栈添加一个新的记录，当我们点击浏览器的返回按钮时可以看到之前的页面。 二、go 页面路由跳转 前进或者后退 this.$router.go(-1) // 后退 三、replace push 方法会向 history 栈添加一个新的记录，而replace方法是替换当前的页面，不会向 history 栈添加一个新的记录. 12&#x2F;&#x2F; 一般使用replace来做404页面this.$router.replace(&#39;&#x2F;&#39;) 配置路由时path有时候会加 / 有时候不加,以 / 开头的会被当作根路径，就不会一直嵌套之前的路径。 route$route 是一个跳转的路由对象，route对象表示当前的路由信息，包含了当前 URL 解析得到的信息，每一个路由都会有一个 route 对象，是一个局部的对象，可以获取对应的 name,path,params,query 等。 $route 是不可变的，每次成功的导航后都会产生一个新的对象. $route.path 字符串，对应当前路由的路径，总是解析为绝对路径，如”/foo/bar”。 $route.params一个 key/value 对象，包含了 动态片段 和 全匹配片段， 如果没有路由参数，就是一个空对象。 $route.query 一个 key/value 对象，表示 URL 查询参数。。 $route.hash 当前路由的hash值 (不带#) ，如果没有 hash 值，则为空字符串。锚点* $route.fullPath 完成解析后的 URL，包含查询参数和hash的完整路径。 $route.matched 数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象。 $route.name 当前路径名字 $route.meta 路由元信息 本文来自 「繁华落烬，戏命如诗」","categories":[{"name":"前端","slug":"前端","permalink":"http://arthurwang.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"前端/Vue","permalink":"http://arthurwang.top/categories/%E5%89%8D%E7%AB%AF/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://arthurwang.top/tags/Vue/"},{"name":"前端","slug":"前端","permalink":"http://arthurwang.top/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"如何选择开源许可证？","slug":"free-software-licenses","date":"2020-02-06T17:36:08.000Z","updated":"2020-02-06T17:59:19.000Z","comments":true,"path":"2020/02/07/free-software-licenses/","link":"","permalink":"http://arthurwang.top/2020/02/07/free-software-licenses/","excerpt":"","text":"如何为代码选择开源许可证，这是一个问题。 世界上的开源许可证，大概有上百种。很少有人搞得清楚它们的区别。即使在最流行的六种—-GPL、BSD、MIT、Mozilla、Apache和LGPL—-之中做选择，也很复杂。 乌克兰程序员Paul Bagwell，画了一张分析图，说明应该怎么选择。这是我见过的最简单的讲解，只用两分钟，你就能搞清楚这六种许可证之间的最大区别。 本文来自 阮一峰的网络日志","categories":[{"name":"tools","slug":"tools","permalink":"http://arthurwang.top/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"http://arthurwang.top/tags/tools/"}]},{"title":"CSS3 box-shadow 属性详解","slug":"css3-box-shadow","date":"2020-02-06T08:23:49.000Z","updated":"2020-02-06T18:01:54.000Z","comments":true,"path":"2020/02/06/css3-box-shadow/","link":"","permalink":"http://arthurwang.top/2020/02/06/css3-box-shadow/","excerpt":"","text":"CSS3定义了两种阴影：盒子阴影和文本阴影。其中盒子阴影需要IE9及其更新版本，而文本阴影需要IE10及其更新版本。下面分别介绍box-shadow阴影的使用： 盒子阴影box-shadowbox-shadow属性向box添加一个或多个阴影。 语法： 12box-shadow: offset-x offset-y blur spread color inset;box-shadow: X轴偏移量 Y轴偏移量 [阴影模糊半径] [阴影扩展] [阴影颜色] [投影方式]; 词解释：blur:模糊 spread:伸展 inset:内凹 参数解释： offset-x：必需，取值正负都可。offset-x水平阴影的位置。 offset-y：必需，取值正负都可。offset-y垂直阴影的位置。 blur:可选，只能取正值。blur-radius阴影模糊半径，0即无模糊效果，值越大阴影边缘越模糊。 spread：可选，取值正负都可。spread代表阴影的周长向四周扩展的尺寸，正值，阴影扩大，负值阴影缩小。 color:可选。阴影的颜色。如果不设置，浏览器会取默认颜色，通常是黑色，但各浏览器默认颜色有差异，建议不要省略。可以是rgb(250,0,0)，也可以是有透明值的rgba(250,0,0,0.5)。 inset:可选。关键字，将外部投影(默认outset)改为内部投影。inset 阴影在背景之上，内容之下。 注意：inset 可以写在参数的第一个或最后一个，其它位置是无效的。 box-shadow 使用水平垂直偏移为0也可以有阴影如果offset-x或offset-y值为0，则阴影在元素背后，此时给blur-radius值或spread值可以产生阴影效果。 但是有一点要注意：扩展阴影必须和阴影模糊半径配合使用。 我个人觉得应该是没有配合使用这一说，但不可能只设置扩展阴影，因为扩展阴影和阴影模糊的取值都可以为正。如果只有扩展阴影的话，会被浏览器当做模糊阴影来解析，所以也可以简单理解为“扩展阴影必须和阴影模糊半径配合使用”，如果只用扩展阴影，可以写成： box-shadow:0 0 0 1px;。 代码示例： 123456789101112131415161718192021222324252627&lt;style&gt; div&#123; width: 100px; height: 100px; margin:50px; border: 10px dotted red; display: inline-block; &#125; .blur&#123; box-shadow: 0 0 20px ; &#x2F;*box-shadow: 0 0 20px green;*&#x2F; &#x2F;*也可以自定义颜色*&#x2F; &#125; .spread-positive&#123; box-shadow: 0 0 20px 5px ; &#x2F;* box-shadow: 0 0 20px 5px green;*&#x2F; &#x2F;*也可以自定义颜色*&#x2F; &#125; .spread-negative&#123; box-shadow: 0 0 20px -5px ; &#x2F;* box-shadow: 0 0 20px -5px green;*&#x2F; &#x2F;*也可以自定义颜色*&#x2F; &#125; &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;div class&#x3D;&quot;blur&quot;&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;spread-positive&quot;&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;spread-negative&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; 设置水平垂直偏移得到阴影效果outset情况：水平垂直偏移为0，但是不设置blur和spread，看不到阴影，因为此时box-shadow的周长和border-box一样，所以可以通过设置偏移让阴影显示出来。 inset情况：水平垂直偏移为0，不设置blur和spread，同样看不到阴影，因为此时box-shadow的周长和padding-box一样，同样可通过设置偏移让阴影显示出来。 代码示例： 1234567891011121314151617181920212223&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;div&#123; width: 100px; height: 100px; margin:50px; border: 10px dotted pink; display: inline-block;&#125;.shadow0&#123;box-shadow: 0 0;&#125; .shadow1&#123;box-shadow: 1px 1px;&#125;.shadow10&#123;box-shadow: 10px 10px;&#125;.inset-shadow0&#123;box-shadow: 0 0 inset;&#125; .inset-shadow1&#123;box-shadow: 1px 1px inset;&#125;.inset-shadow10&#123;box-shadow: 10px 10px inset;&#125;&lt;&#x2F;style&gt;&lt;body&gt; &lt;div class&#x3D;&quot;shadow0&quot;&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;shadow1&quot;&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;shadow10&quot;&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;inset-shadow0&quot;&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;inset-shadow1&quot;&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;inset-shadow10&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; 投影方式投影方式默认是outset，即外部投影，可设置inset让向内投影。 例子：第一个div默认outset，第二个设置inset，第三个同时设置两个阴影可以更好的看到outset和inset的关系，第四个div可以看出inset阴影在背景之上，内容之下。 12345678910111213141516171819202122232425262728&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;div&#123; width: 100px; height: 100px; margin:50px; border: 10px dotted pink; display: inline-block; vertical-align: top;&#125; .outset&#123; box-shadow: 10px 10px teal;&#125;.inset&#123; box-shadow: 10px 10px teal inset; &#125;.double&#123; box-shadow: 10px 10px teal inset,10px 10px teal;&#125;.bg&#123; background-color: yellow;&#125;&lt;&#x2F;style&gt;&lt;body&gt; &lt;div class&#x3D;&quot;outset&quot;&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;inset&quot;&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;double&quot;&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;inset bg&quot;&gt;inset阴影在背景之上，内容之下&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; 如果元素同时指定border-radius属性，则阴影呈现相同的圆角12345678910111213141516&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt; div&#123; width: 100px; height: 100px; margin:50px; border: 10px dotted pink; display: inline-block; border-radius: 50px; &#125;.shadow&#123; box-shadow: 0 0 10px 10px green;&#125;&lt;&#x2F;style&gt;&lt;body&gt;&lt;div class&#x3D;&quot;shadow&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; 经典例子w3c中的一个例子 border-radius会以相同的作用影响阴影外形 border-image,padding不会影响阴影的任何外形 阴影box和box模型一样 外阴影在对象背景之下，内阴影在背景之上。 层次：内容&gt;内阴影&gt;背景图片&gt;背景颜色&gt;外阴影 多重阴影语法：可以设置任意多个阴影，用逗号隔开。 一个box有多重阴影时，需要注意顺序：多个阴影从上往下分布，第一个阴影在最顶层。 举例：单边阴影效果 先解释一下：可单独设置左边框的阴影，右边框的阴影，上边框的阴影，下边框的阴影，其实这样说也对，因为效果看起来就是这样，但根本原因是阴影在盒子后面，只是让阴影的位置发生了变化，其他3 个边的阴影还是存在的，只是被覆盖住了而已，所以，设置某个边的阴影是个很虚的东东了，哎，网上这种说法初看还让我略感困惑，所以我这里说是单边阴影效果，告诉大家只是一种效果，本质还是个box。 例子解释：给第一个div的上右下左border分别设置红橙黄绿，四种颜色，则red-shadow在最顶层，green-shadow在最底层，如下图左。给其加上blur模糊半径，效果更明显，如下图中，可见red-shadow的模糊半径不受干扰，因为在最顶层；接下来orange-shadow次之，被red-shadow的radius干扰；yellow-shadow被orange-shadow和red-shadow的radius干扰；同理green-shadow被它上面的所有shadow的radius干扰。 如果还是不太理解，那给red-shadow设置一个很大的radius，比如50，就可以看到非常明显的效果了。 1234567891011121314151617181920212223242526272829303132&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;div&#123; width: 100px; height: 100px; margin:50px; display: inline-block; border: 10px dotted pink;&#125;.shadow&#123; box-shadow: 0 -5px red, 5px 0 orange, 0 5px yellow, -5px 0 green;&#125;.blur-shadow&#123; box-shadow: 0 -5px 5px red, 5px 0 5px orange, 0 5px 5px yellow, -5px 0 5px green;&#125;.big-redShadow&#123; box-shadow: 0 -5px 50px red, 5px 0 5px orange, 0 5px 5px yellow, -5px 0 5px green;&#125;&lt;&#x2F;style&gt;&lt;body&gt; &lt;div class&#x3D;&quot;shadow&quot;&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;blur-shadow&quot;&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;big-redShadow&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; 阴影和布局阴影不影响布局， 但是可能会覆盖其他box或者其他box的阴影。 阴影不触发滚动条，也不增加滚动区域的大小。 所以布局时可忽略阴影。 spread妙用用spread模拟实现border 1234567891011121314151617181920212223&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;div&#123; width: 100px; height: 100px; display: inline-block; margin:10px; vertical-align: top;&#125;.border&#123; border:1px solid red;&#125;.spread&#123; box-shadow: 0 0 0 1px red;&#125;.muli-border&#123; box-shadow: 0 0 0 2px red,0 0 0 4px green,0 0 0 6px blue;&#125;&lt;&#x2F;style&gt;&lt;body&gt; &lt;div class&#x3D;&quot;border&quot;&gt;border&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;spread&quot;&gt;box-shadow&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;muli-border&quot;&gt;多重&lt;br&#x2F;&gt;box-shadow&lt;&#x2F;div&gt;&lt;&#x2F;body&gt; 用spread实现双色方括号 1234567891011&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;.decorator &#123;width: 300px;height: 100px;padding: 30px;box-shadow: -30px -30px 0 -25px red,30px 30px 0 -25px green; &#125;&lt;&#x2F;style&gt;&lt;body&gt;&lt;div class&#x3D;&quot;decorator&quot;&gt;段落内容：用box-shadow模拟双色方括号box-shadow: -24px -24px 0 -20px red,24px 24px 0 -20px green; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt; 本文来自 「巧克力很苦」 一些链接： The box-shadow Property","categories":[{"name":"前端","slug":"前端","permalink":"http://arthurwang.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"http://arthurwang.top/categories/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://arthurwang.top/tags/CSS/"}]},{"title":"CSS之flex兼容","slug":"flex-compatible","date":"2020-02-02T16:14:02.000Z","updated":"2020-02-02T16:21:08.000Z","comments":true,"path":"2020/02/03/flex-compatible/","link":"","permalink":"http://arthurwang.top/2020/02/03/flex-compatible/","excerpt":"","text":"flex布局分为旧版本 dispaly: box;，过渡版本 dispaly: flex box;，以及现在的标准版本 display: flex;。所以如果你只是写新版本的语法形式，是肯定存在兼容性问题的。 Android 2.3 开始就支持旧版本 display:-webkit-box; 4.4 开始支持标准版本 display: flex; IOS 6.1 开始支持旧版本 display:-webkit-box; 7.1 开始支持标准版本 display: flex; PC ie10开始支持，但是IE10的是-ms形式的。 兼容方法： 1234567891011121314151617.box&#123; display: -webkit-flex; &#x2F;* 新版本语法: Chrome 21+ *&#x2F; display: flex; &#x2F;* 新版本语法: Opera 12.1, Firefox 22+ *&#x2F; display: -webkit-box; &#x2F;* 老版本语法: Safari, iOS, Android browser, older WebKit browsers. *&#x2F; display: -moz-box; &#x2F;* 老版本语法: Firefox (buggy) *&#x2F; display: -ms-flexbox; &#x2F;* 混合版本语法: IE 10 *&#x2F; &#125;.flex1 &#123; -webkit-flex: 1; &#x2F;* Chrome *&#x2F; -ms-flex: 1 &#x2F;* IE 10 *&#x2F; flex: 1; &#x2F;* NEW, Spec - Opera 12.1, Firefox 20+ *&#x2F; -webkit-box-flex: 1 &#x2F;* OLD - iOS 6-, Safari 3.1-6 *&#x2F; -moz-box-flex: 1; &#x2F;* OLD - Firefox 19- *&#x2F; &#125; 本文来自 贺贺V5","categories":[{"name":"前端","slug":"前端","permalink":"http://arthurwang.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"http://arthurwang.top/categories/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://arthurwang.top/tags/CSS/"},{"name":"flex","slug":"flex","permalink":"http://arthurwang.top/tags/flex/"}]},{"title":"原生和jQuery的ajax用法","slug":"js-jquery-ajax","date":"2020-02-02T15:58:55.000Z","updated":"2020-02-06T18:03:10.000Z","comments":true,"path":"2020/02/02/js-jquery-ajax/","link":"","permalink":"http://arthurwang.top/2020/02/02/js-jquery-ajax/","excerpt":"","text":"form数据的序列化： 12345678910$(&#39;#submit&#39;).click(function()&#123; $(&#39;#form&#39;).serialize(); &#x2F;&#x2F;会根据input里面的name，把数据序列化成字符串；eg：name&#x3D;yang $(&#39;#form&#39;).serializeArray(); &#x2F;&#x2F;会根据input里面的name，把数据序列化成数组；eg：[object] &#x2F;&#x2F;注意：没有name会获取不到值 &#x2F;&#x2F;下面两种不是jQuery的方法 JSON.parse() &#x2F;&#x2F;json字符串转化为json对象 JSON.stringify() &#x2F;&#x2F;json对象转化为json字符串&#125;); jQuery的ajax方法： 123456789101112131415161718192021222324252627$.ajax(&#123; url:&#39;&#x2F;comm&#x2F;test1.php&#39;, type:&#39;POST&#39;, &#x2F;&#x2F;GET async:true, &#x2F;&#x2F;或false,是否异步 data:&#123; name:&#39;yang&#39;,age:25 &#125;, timeout:5000, &#x2F;&#x2F;超时时间 dataType:&#39;json&#39;, &#x2F;&#x2F;返回的数据格式：json&#x2F;xml&#x2F;html&#x2F;script&#x2F;jsonp&#x2F;text beforeSend:function(xhr)&#123; console.log(xhr) console.log(&#39;发送前&#39;) &#125;, success:function(data,textStatus,jqXHR)&#123; console.log(data) console.log(textStatus) console.log(jqXHR) &#125;, error:function(xhr,textStatus)&#123; console.log(&#39;错误&#39;) console.log(xhr) console.log(textStatus) &#125;, complete:function()&#123; console.log(&#39;结束&#39;) &#125;&#125;) 原生的ajax方法： 123456789101112131415161718192021$(&#39;#send&#39;).click(function()&#123; &#x2F;&#x2F;请求的5个阶段，对应readyState的值 &#x2F;&#x2F;0: 未初始化，send方法未调用； &#x2F;&#x2F;1: 正在发送请求，send方法已调用； &#x2F;&#x2F;2: 请求发送完毕，send方法执行完毕； &#x2F;&#x2F;3: 正在解析响应内容； &#x2F;&#x2F;4: 响应内容解析完毕； var data &#x3D; &#39;name&#x3D;yang&#39;; var xhr &#x3D; new XMLHttpRequest(); &#x2F;&#x2F;创建一个ajax对象 xhr.onreadystatechange &#x3D; function(event)&#123; &#x2F;&#x2F;对ajax对象进行监听 if(xhr.readyState &#x3D;&#x3D; 4)&#123; &#x2F;&#x2F;4表示解析完毕 if(xhr.status &#x3D;&#x3D; 200)&#123; &#x2F;&#x2F;200为正常返回 console.log(xhr) &#125; &#125; &#125;; xhr.open(&#39;POST&#39;,&#39;url&#39;,true); &#x2F;&#x2F;建立连接，参数一：发送方式，二：请求地址，三：是否异步，true为异步 xhr.setRequestHeader(&#39;Content-type&#39;,&#39;application&#x2F;x-www-form-urlencoded&#39;); &#x2F;&#x2F;可有可无 xhr.send(data); &#x2F;&#x2F;发送&#125;); 本文来自 程序大大","categories":[{"name":"前端","slug":"前端","permalink":"http://arthurwang.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"http://arthurwang.top/categories/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://arthurwang.top/tags/JavaScript/"}]},{"title":"MAC升级Nodejs和Npm到最新版","slug":"mac-update-node","date":"2020-02-02T15:47:25.000Z","updated":"2020-02-02T15:52:49.000Z","comments":true,"path":"2020/02/02/mac-update-node/","link":"","permalink":"http://arthurwang.top/2020/02/02/mac-update-node/","excerpt":"","text":"第一步，先查看本机node.js版本1node -v 第二步，清除node.js的cache1sudo npm cache clean -f 第三步，安装 n 工具这个工具是专门用来管理node.js版本的，别怀疑这个工具的名字，是他是他就是他，他的名字就是 “n” 1sudo npm install -g n 第四步，安装最新版本的node.js1sudo n stable 第五步，再次查看本机的node.js版本1node -v 第六步，更新npm到最新版1$ sudo npm install npm@latest -g 第七步，验证12node -vnpm -v 本文来自 南方帅","categories":[{"name":"tools","slug":"tools","permalink":"http://arthurwang.top/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"http://arthurwang.top/tags/tools/"},{"name":"node","slug":"node","permalink":"http://arthurwang.top/tags/node/"}]},{"title":"数组的push()、pop()、shift()和unshift()方法","slug":"js-array-push","date":"2020-02-02T08:14:36.000Z","updated":"2020-02-02T08:46:59.000Z","comments":true,"path":"2020/02/02/js-array-push/","link":"","permalink":"http://arthurwang.top/2020/02/02/js-array-push/","excerpt":"","text":"JavaScript的数组是一个拥有堆栈和队列自身优点的global对象。也就是说JavaScript数组可以表现的像栈(LIFO)和队列(FIFO)一样操作。这也是JavaScript数组强大的可操作性的体现。 堆栈和队列栈和队列都是动态的集合，在栈中，可以去掉的元素是最近插入的那一个。栈实现了后进先出。在队列中，可以去掉的元素总是在集合中存在的时间最长的那一个。队列实现了先进先出的策略。 堆栈的基本概念先上张图： ECMAScript为数组专门提供了 shift() 和 unshift() 方法，以便实现类似队列的行为。由于 push() 是向数组末端添加数组项的方法，因此要模拟队列只需一个从数组前端取得数组项的方法。实现这一操作的数组方法就是 shift() ，它能够移除数组中的第一个项并返回该项，同时将数组长度减1。 顾名思义， unshift() 与 shift() 的用途相反：它能在数组前端添加任意个数组项并返回新数组的长度。因此，同时使用 unshift() 和 pop() 方法，可以从相反的方向来模拟队列，即在数组的前端添加数组项，从数组末端移除数组项。 简单得回忆一下： push() 方法可以在数组的末属添加一个或多个元素 shift() 方法把数组中的第一个元素删除 unshift()方法可以在数组的前端添加一个或多个元素 pop() 方法把数组中的最后一个元素删除 实现类似栈的行为将 push() 和 pop() 结合在一起，我们就可以实现类似栈的行为： 123456789101112131415161718192021222324&#x2F;&#x2F;创建一个数组来模拟堆栈var a &#x3D; new Array();console.log(a);&#x2F;&#x2F;push: 在数组的末尾添加一个或更多元素，并返回新的长度console.log(&quot;入栈&quot;);a.push(1);console.log(a); &#x2F;&#x2F;-----&gt;1a.push(2);console.log(a); &#x2F;&#x2F;-----&gt;1,2a.push(3);console.log(a); &#x2F;&#x2F;-----&gt;1,2,3a.push(4);console.log(a); &#x2F;&#x2F;-----&gt;1,2,3,4console.log(&quot;出栈 后进先出&quot;);console.log(a);&#x2F;&#x2F;pop: 从数组中把最后一个元素删除，并返回这个元素的值a.pop();console.log(a); &#x2F;&#x2F;-----&gt;4a.pop();console.log(a); &#x2F;&#x2F;-----&gt;3a.pop();console.log(a); &#x2F;&#x2F;-----&gt;2a.pop();console.log(a); &#x2F;&#x2F;-----&gt;1 在Chrome浏览器控制台输出的效果如下图所示： 123456789101112[]入栈[1][1, 2][1, 2, 3][1, 2, 3, 4]出栈 后进先出[1, 2, 3, 4][1, 2, 3][1, 2][1][] 实现类似队列的行为将 shift() 和 push() 方法结合在一起，可以像使用队列一样使用数组。即在数组的后端添加项，从数组的前端移除项： 123456789101112131415161718192021222324&#x2F;&#x2F;创建一个数组来模拟队列var a &#x3D; new Array();console.log(a);&#x2F;&#x2F;push: 在数组的末尾添加一个或更多元素，并返回新的长度console.log(&quot;入栈&quot;);a.push(1);console.log(a); &#x2F;&#x2F;-----&gt;1a.push(2);console.log(a); &#x2F;&#x2F;-----&gt;1,2a.push(3);console.log(a); &#x2F;&#x2F;-----&gt;1,2,3a.push(4);console.log(a); &#x2F;&#x2F;-----&gt;1,2,3,4console.log(&quot;出队 先进先出&quot;);console.log(a);&#x2F;&#x2F;shift: 从数组中把第一个元素删除，并返回这个元素的值a.shift();console.log(a); &#x2F;&#x2F;-----&gt;1a.shift();console.log(a); &#x2F;&#x2F;-----&gt;2a.shift();console.log(a); &#x2F;&#x2F;-----&gt;3a.shift();console.log(a); &#x2F;&#x2F;-----&gt;4 在Chrome浏览器控制台输出的效果如下图所示： 123456789101112[]入队[1][1, 2][1, 2, 3][1, 2, 3, 4]出队 先进先出[1, 2, 3, 4][2, 3, 4][3, 4][4][] 除此之外，还可以同时使用 unshift() 和 pop() 方法，从相反的方向来模拟队列，即在数组的前端添加项，从数组的后端移除项。 本文来自 luck_lin","categories":[{"name":"前端","slug":"前端","permalink":"http://arthurwang.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"http://arthurwang.top/categories/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://arthurwang.top/tags/JavaScript/"}]},{"title":"20 结束语：大道行思,取则行远","slug":"eq-20","date":"2020-01-20T11:57:55.000Z","updated":"2020-02-02T16:35:58.000Z","comments":true,"path":"2020/01/20/eq-20/","link":"","permalink":"http://arthurwang.top/2020/01/20/eq-20/","excerpt":"","text":"没有智慧的头脑，就象没有腊烛的灯笼。——列夫·托尔斯泰 大家好，我是风落。熟悉我的朋友一看到这种 “拽文” 的题目，就知道风落又要跟大家说再见了。 这次的专栏于我自己而言是一次特殊的尝试，也是一个真正想跟大伙说点真话的专栏。这段时间里，就专栏的主题我也一直在跟自己的朋友、学生讨论，专栏的内容也不断在修改，从 “写一些我想跟大家说的” 变成 “大家想听我说的”。 很多同学一直在问我：BAT 是怎么样的？工作情况如何？办公室环境还好么？我想这一次能够很好地给大家回答了。 本来以为经过上一次测试专栏的挑战，这次应该更加得心应手才是，然而提笔之后才发现，这样的一个专栏看起来好像想写到哪儿写到哪儿，想说什么就说什么，实际上把自己真正内心的话通过文字表达出来也并不容易。 正像我开头写的，我希望我能够把我自己亲身经历的、有感而发的 “职场那些事儿” 分享给大家，希望能够对大家有所启迪和帮助。 所以我们在这个专栏里，聊了 996、聊了 “抢功”、聊了 “背锅” 更聊了 “站队” 等等敏感的话题，这些话题有的是我计划好的，有的是我中途加入的。总之我希望的是能够给每个 “职场人”、每个 “程序员” 都带来一点点改变：让大家认识更 “真实” 的职场，让大家了解 “程序员” 不仅仅只需要技术。 我相信每一个 IT 人，只要你愿意，这方面你可以做得更好。所以就像我们这篇结束语的题目一样：大道行思，取则行远。 大概的意思就是：正道而行，善于思考，且行且思，探究规律，把握大道，然后取法于大道与规律，就能于法则和天道无违，而行得稳而远。 最后几多的不舍化作一句希望：希望大家能少走一些职场上的 “弯路”，越行越远。 青山不改，绿水长流，江湖再见，后会有期。 本文来自 风落几番 / 蚂蚁金服测试专家","categories":[{"name":"articles","slug":"articles","permalink":"http://arthurwang.top/categories/articles/"}],"tags":[{"name":"articles","slug":"articles","permalink":"http://arthurwang.top/tags/articles/"},{"name":"EQ","slug":"EQ","permalink":"http://arthurwang.top/tags/EQ/"}]},{"title":"19 从“年薪170w大牛征婚”聊起","slug":"eq-19","date":"2020-01-20T10:57:55.000Z","updated":"2020-02-02T16:35:50.000Z","comments":true,"path":"2020/01/20/eq-19/","link":"","permalink":"http://arthurwang.top/2020/01/20/eq-19/","excerpt":"","text":"散步促进我的思想。我的身体必须不断运动，脑筋才会开动起来。—— 卢梭 今天的话题我们从一则 “旧闻” 聊起： 这是一则在微博上被喷惨了的 “阿里年薪 170w 大牛征婚帖”。 我们摘要总结一下： 阿里 P8（纵观阿里内部，能登上 P8 者不多），男，安徽农村人，86 年，211 本 985 硕，已有京户，北苑 120 三居（200 万贷款），特斯拉 m3（截止成文新车价值 50w 左右），170cm/65kg，年收入 170 万，未来看涨。 征婚要求呢，希望是江浙 90 后城市家庭独生女，211 本，年收入 12 万 +，身高 162+，外貌佳，父母养老无忧。愿意要 2 孩，婚后多照顾家庭。 附加：婚后独立出 200 万再买一套，意思就是女方获 100 万权益。 我大概是第二时间看到的这篇征婚启事，第一反应是什么呢？ 出色，牛。 感觉出身平凡甚至贫寒，安徽高考大省，依靠教育改变命运。换了我，如果不是出生自带直辖市户口本，我非常不确定自己能成为 985 本的一员。纵使先天强于人家，但是我也没考研…… 170 万年薪的话，符合 P8 定位，肯定没吹牛，别看网上经常 “年薪百万”、“刚下飞机”，实际上即使是在北上广深一线城市，年收入实打实有 170 万的也绝对是人中龙凤，精英中的精英，按收入算大概能进 top 1%。 对女方的要求吧，虽然确实不低，但是也并不算非常出众。但是评论席里呢？骂声一片。 我仔细看了下，核心的骂声来源于： 男的农村，要女的城市。男的自己有姐，要女的独生。男的自己安徽，要女的浙江江苏，安徽只是 “也可”。婚后要求女方牺牲事业，专注生孩子和照顾家庭。 说明什么，这种农村城市、独生地域的要求隐隐透露出男方自己内心自卑，有可能是凤凰男，更是大有 “之前穷时候觉得配不上现在觉得没问题” 的这种 “金钱至上” 思想。男方后续买房其实也就出了 200 万首付，这对于江浙小康家庭而言也并不是什么了不起的巨款。 想了想，似乎换个角度想，骂的也挺有道理。跟媳妇跟同事都聊了一下，大伙觉得核心呢，就是江浙地区一二线城市名校白领独生女，其实犯不着靠婚姻改变生活。对于条件不错的女生而言，钱的效用降低了很多，更关注的是男方有没有其他短板，而不只盯着钱来择偶。 所以这大约就是一种说话的艺术，择偶时不要过于强调金钱，否则女方会觉得你在用钱砸她，除非女的被穷怕了，很缺钱，如果男方目标是优秀女性，则会很容易激起情绪反弹。 这个哥们一不小心变成了让全网 “讨厌” 的那种人。 我突然在想一个问题，如果把这个征婚启事反过来会怎样？ 本人女，91 年杭州生人，身高 165，体重 48kg，身材和容貌中等偏上。211 高校本科毕业，目前某外企职员，年薪 12 万 +，可以养活自己。独生子女，父母都是退休职工，负担不大。喜欢小孩，婚后希望能养育 1-2 个。理想中的他：比我大 3-6 岁，重点大学本科以上学历，身高比我高， 170cm 以上，在北京或上海一线城市有安家落户的经济基础，有房有车，年薪百万以上最好，婚后可以专注于家庭，成为贤内助。 我估计啊，如果是这样的帖子，下边更是骂声一片。为什么呢？集中会骂在对男方经济要求过高之上，尤其 “有房有车年薪百万”，简直就是让人气愤难平。 这就很奇怪了，正着说反正说似乎都会被骂，真是众口难调。我想，这就是语言的艺术了。我们讲究的 “情商高”、“会说话” 一定是更委婉、更含蓄，比如一个测试要跟开发反馈一个 BUG： 所以，职场上我们强调的情商应该是：能准确表达自己的意思，同时也不要让别人觉得非常不舒服。 如果这个阿里大牛的征婚里更多强调自己的幽默、风趣，更诙谐一点表明自己头发少但智商高，更隐晦地表达自己对于女方的需求，再淡淡地表达自己的薪水、股票，我想效果会更好一点。 虽然着实不认识这个哥们，但是我其实还蛮理解他的。记得我在追我媳妇之前，犹豫了很久，因为当时自己比较穷家里还有欠款，自觉条件配不上她。直到后来有所改善才再次 “下手”。 无论情商如何，说话的艺术怎样，征婚这个事情，也只需要碰到一个合适的就 OK 了，以他的条件我相信没问题。 但是职场上，还是劝大家，“好好说话”。 本文来自 风落几番 / 蚂蚁金服测试专家","categories":[{"name":"articles","slug":"articles","permalink":"http://arthurwang.top/categories/articles/"}],"tags":[{"name":"articles","slug":"articles","permalink":"http://arthurwang.top/tags/articles/"},{"name":"EQ","slug":"EQ","permalink":"http://arthurwang.top/tags/EQ/"}]},{"title":"18 别输在“情绪管理”","slug":"eq-18","date":"2020-01-20T05:57:55.000Z","updated":"2020-02-02T16:35:40.000Z","comments":true,"path":"2020/01/20/eq-18/","link":"","permalink":"http://arthurwang.top/2020/01/20/eq-18/","excerpt":"","text":"人生的旅途，前途很远，也很暗。然而不要怕，不怕的人的面前才有路。—— 鲁 迅 刚刚入秋的时候，某次跟老友相约在一个环境不错的茶馆喝茶，一方面是难得在繁忙之余休息一下，另一方面也是在一个幽然的环境中平和一下自己在工作中积攒的 “戾气”。 一坐便是一个下午，席间聊起一个话题，老友问我：如果要你给刚毕业的孩子们讲一堂职场课，你会选什么主题？ 不知道是不是因为平静的湖面影响了我的心境，我脱口而出：大概是情绪管理吧。 先来讲个小故事（小灰口口声声非要说自己是只乖巧的程序兔，这个故事小灰坚决不要出场)： 一名 90 后职场新人，入职新公司不久被领导批评，一怒之下甩手辞职。怒气未消，临走之际还借助自己的员工权限，将公司淘宝与天猫后台的数据一键删除。90 后职场新人年轻气盛、个性张扬、发泄怒火的结果，却换来了被当地检察院以 “破坏生产经营罪” 提起公诉。 这是一起由于生气、委屈而情绪失控的错误。可能听上去略微有一些极端，实际上在职场上类似的情绪却并不少见：会议中因为某个问题从针锋相对、固执己见发展到拍桌子大吼；讨论过程中由于自己的观点没有得到认可而大发雷霆，扬长而去；因为领导的某句话、某件事而喋喋不休的抱怨。 这些看起来稀松平常的事情，其实都是某种 “情绪失控” 的表现。很多人，尤其是初入职场的人，往往忽视了 “情绪管理”，认为自己的表现是 “真性情”，认为自己就是这样的人这样的性格，这样做没有什么很严重的问题。 然而实际上，像前边故事中情绪过度失控带来的影响是全方位的。无论希望现在的职场，或者未来创业上有所成就，都应该有意识地提升自己的情绪管理能力。情绪管理能力是职场情商的重要体现。 有的同学要说了：风落，你这是要告诉我们职场不可以有 “真性情” 么？要戴着面具伪装自己不能有情绪么？ 非也。且听我徐徐道来。 为什么要管理情绪？ 职场绝对不能杜绝也没办法杜绝 “情绪” 的存在。情绪这种东西，是人的本能，喜怒哀乐都是正常的情绪表现。 但是我觉得，我们需要管理的、或者说需要避免的，是情绪失控。 我们都知道，程序员是一群很简单的人。我们接触的大多是没有思想的代码，看到的是亲切又疏远的电脑屏幕。往往越是纯粹的人，情绪越容易失控。刚出生不久的孩子不会因为周围都是陌生人而克制自己的哭声，心思简单的小朋友也不会在乎别人的目光而放弃在游乐场边打滚哭闹，“熊孩子” 们不会害怕在地铁上其他人不高兴而让自己不在拥挤的环境中跑来跑去。 在我的身边，因为一个 BUG 的修复而开心到忘乎所以，因为其他人的否定而生气到摔杯子砸键盘，因为绩效考评差或者被领导批评而消极到怠惰拖延的情形比比皆是。 我觉得，我们可能很多时候，把 “真性情” 理解错了，变成了别人眼中的 “真神经”。 所以，我们说的 “控制情绪”，不是要你戴着面具，面无表情地做人，而是不要过分陷入自己的情绪之中，“不专业” 地与人交流或工作，以自己的情绪而左右自己的职业行为。 如何进行自我情绪管理 老实说，刚工作时的我、刚做讲师的我都存在着不同程度的情绪失控。初入职场的时候，经常因为头脑一热，就说出一些过激的话，甚至有时候明知对方可能是正确的，却嘴硬地梗着脖子与对方 “血战到底”。初为人师的时候，经常由于学生的不开窍而暴怒不已，各种 “情绪暴力”。 一段时间以来，当我认识到：当我自己情绪失控的时候，其实说出的话对于对方更是一种攻击；受到攻击的对方也会受到你情绪的传染，在没有察觉的情况下，从 “交流” 升级为斗争。而一旦我们开始了斗争，处于 “愤怒” 之下的我们，也缺乏了足够的理性判断，双方更会失去了讨论的初衷，沉浸在失控的情绪中。最终，“情绪” 无法解决问题，“失控的情绪” 更会阻碍问题地解决。 控制情绪的第一步从管理冲突时刻做起。 面对情绪冲突的时候，不管对方说了什么不好的话，也不管你的情绪多么差–可能你昨天刚刚与另一半吵架，可能与父母因为相亲闹的不开心，也可能刚刚被领导骂了一顿，又可能你昨天刚刚被房东赶出了曾经的 “家”–无论你有多么愤怒，在说出任何话语之前先做一次深呼吸，也可以学习小灰默念一下这句 “名言”。如果情绪平静了一点，那么就理性地思考一下讨论的方向，并且在开口前想想如果你是对方，这句话是否会让你自己暴走；当然，如果情绪仍然在 “愤怒” 的状态之中，那就更简单了，两个字–“闭嘴”。不是让对方闭嘴，而是你自己给自己暂时禁言。 不知道大伙有没有跟自己的另一半吵过架。情绪嘛，就是一个从积累到发作到下降的过程。吵架的时候我们都会让自己冷静一下，避免说出伤害对方的话。职场上也是如此。 接下来就是情绪的宣泄和平复。这个每个人会有每个人的方式，没有啥官方可以推荐的。有的人通过吃饭、逛街、买买买来宣泄，有的人可能会选择捏碎一包包方便面来让自己解压。当然，也有的朋友需要一只可以陪你倾听 “小黄鸭”。 宣泄之后更重要的是对于 “情绪失控” 的复盘。我更习惯于在一个安静的环境中，比如开篇展示的湖畔茶舍，或者是舒服的海边、又或者是温暖的咖啡吧。在这样能让你平静下来的地方，回想一下自己情绪失控的过程。 很多时候，你从旁观者的角度回想一下自己的处理方式，就会发现自己当时的情绪是多么愚蠢和可笑。这样，也能够让你未来在面对情绪冲突的当下，也能够让自己更心平气和的 “暂时闭嘴”。 当然，每个人都有自己的困扰，不管我们是不是程序员，一样面对着家庭的琐碎、生活的压力、职场的瓶颈，我们可以宣泄，但是无论何时，记得自己宣泄的场景和对手。宣泄的对象，不该是你的领导上司，不该是你的同事伙伴，也不该是你的父母家人，更不该是你的另一半。找一个更简单的方式，你会发现，生活更美好。 我有一个愿望，希望职场 “和平”。 本文来自 风落几番 / 蚂蚁金服测试专家","categories":[{"name":"articles","slug":"articles","permalink":"http://arthurwang.top/categories/articles/"}],"tags":[{"name":"articles","slug":"articles","permalink":"http://arthurwang.top/tags/articles/"},{"name":"EQ","slug":"EQ","permalink":"http://arthurwang.top/tags/EQ/"}]},{"title":"17 为什么大多数人宁愿吃生活的苦，也不愿意吃学习的苦","slug":"eq-17","date":"2020-01-20T04:57:55.000Z","updated":"2020-02-02T16:35:27.000Z","comments":true,"path":"2020/01/20/eq-17/","link":"","permalink":"http://arthurwang.top/2020/01/20/eq-17/","excerpt":"","text":"时间像海绵里的水，只要你愿意挤，总还是有的。——鲁迅 多年前有过一次很难忘的面试，不是因为被面试的小伙儿有多出众，仅仅是因为他在表现得一塌糊涂后特意加了我微信，离开后却没有问我关于面试结果的事情。 几年来一直断断续续的有所联系，也知道他的一些近况：比如他跟女朋友分手了；比如他换了几个公司，但一直不太满意。 最近有个机会，他约我出来吃了个饭。比起面试时模糊印象中那个乐观开朗的小伙儿来说，眼睛了少了几分当初的神采。酒过三巡，他聊起来自己，说年轻时候觉得自己能力还可以，也算机灵，总会在行业里有自己的一席之地。兜兜转转多年，薪水一直不上不下，工作也不算轻松，但一直做的是比较底层的工作，毫无上升的机会。 我这个人吧，有时候就有点不解风情。这时候我跟他聊了聊他技术上的提升，发现他跟几年前能力相仿，没有太大的进步，技术也停留在多年前。非常小心地提醒他，其实可以多学习学习新技术，这样有机会找到一份好一点的工作。 他很无奈的叹气：唉，都这把岁数了，学习了又能怎样？也就这样了吧。 在 30 岁的年龄就有了 50 岁的感慨，让我有点不知所措。却又明白了今天我们的这个话题：为什么大多数人宁愿吃生活的苦，也不愿意吃学习的苦？ 知乎上有一个回答非常精辟：因为生活的苦躺着甚至是舒服着就吃了，而学习的苦得站起来吃。 让小灰来现身说法一下吧： 小灰也是一只到了试婚年龄的兔子，可是他的女朋友小白坚持要他先买三个窝才能谈结婚的事儿，毕竟老话说的好：狡兔三窟嘛！小灰这个压力有点大，自己薪水略微有点低，于是给自己立了个 flag，晚上下班回家要看一小时设计模式。 等晚上到了家，脑海里就出现了两个小人说话： “今天都这么累了，还是先打会游戏，早点睡，明天再去学习” “好啊好啊” 于是开始享受美好的游戏时光，但是到了睡觉的时间，又感觉精神还挺好，玩的正 happy，于是这两个小人又出来了： “难得玩的挺开心，再玩会儿也没关系的” “对啊对啊” 第二天回到办公室，面对一份不但没有前途更没有钱途的工作，又决定：今天晚上必须得看一小时设计模式。 下班回家，那两个小人又出来了…… 我相信很多人都经历过这样的心路历程，我也不例外。为什么呢？ 简单的说，生活的 “苦” 从长期来看当然是苦，但是短期它是以 “甜” 的形式存在的；学习的 “苦” 那短期来看那是真苦，只有长期才能看到 “甜”。 那么我们其实比较的是：眼前的 “甜”、长期的 “苦” 和眼前的 “苦”、长期的 “甜” 的比较。 换句话说，这是触手可得的短期利益与长期利益的较量。 这时候就很奇怪了，大多数人都很短视么，为什么放弃长期利益于不顾，而选择了短期利益呢？ 不是大家看不见，而是因为长期利益很虚幻，有很大的不确定性。我每天学习一小时，未来就可以获得收益么？但是我玩这一小时游戏立刻可以得到一小时的快乐时光啊。 如果有人习惯性地选择了短期利益，然后每天如此恶性循环，最后自暴自弃，连自己都不相信自己有可能改变。 而另外一点，我们在软件行业、在互联网行业，是更新换代最快的行业。10 年前我们还在用 1 毛 1 条的短信互相联系、查资料还需要到图书馆里、初到陌生城市还需要先买一份地图；现在呢，有方便实时沟通的微信，有无所不知的百度，有遍及各地的地图，当然更有出门几乎不用带钱的支付宝。而 10 年后会怎样？我们谁都不知道。 这就意味着，即使你还是二十五六的青葱少年，若想在我们这个三十五六的年纪还保持在 “尚能饭” 的地位，保持学习、跟上时代是非常重要的。 “保持学习” 才是最好的铁饭碗。 我也希望我自己能够在十年后还站在同一个舞台上与大家聊聊这些年的那些事儿。 我们共勉。 本文来自 风落几番 / 蚂蚁金服测试专家","categories":[{"name":"articles","slug":"articles","permalink":"http://arthurwang.top/categories/articles/"}],"tags":[{"name":"articles","slug":"articles","permalink":"http://arthurwang.top/tags/articles/"},{"name":"EQ","slug":"EQ","permalink":"http://arthurwang.top/tags/EQ/"}]},{"title":"16 职场“站队”难","slug":"eq-16","date":"2020-01-19T10:57:55.000Z","updated":"2020-02-02T16:35:18.000Z","comments":true,"path":"2020/01/19/eq-16/","link":"","permalink":"http://arthurwang.top/2020/01/19/eq-16/","excerpt":"","text":"人只有献身于社会，才能找出那短暂而有风险的生命的意义。——爱因斯坦 有人说过：职场是个名利场，也是个江湖。也有人说过：有人的地方就有斗争。越是规模大的公司，“办公室政治” 也就越激烈。不要觉得我到了 500 强，到了一线互联网，就没有纷争了。 然而做为一只与世无争的程序猿，我们并不想被卷入办公室斗争里去。但是，人在职场大多数时候真的免不了要从几个” 队伍 “里选择一个，这就面临了职场中一个更困难的问题：面对” 站队 “，怎么办？ 这时候一定有同学要说：不站队不就好了，我就好好干活、认真工作就好。 我也有两个学生，入职某一线互联网公司，但是由于觉得” 不站队 “才是最安全的，最终惨淡收场。 职场上的站队不可怕，甚至站错队都不那么可怕，可怕的是没有” 站队 “，为什么呢？ 除非你是真正牛到每个队伍都要拉拢却又拉不动的人，否则如果面对其他队伍初始的” 善意 “视而不见，不去站队，就代表你不是别人的人。那么你想做出成绩那是非常的难，万一出了什么问题，黑锅自然就由你来背，毕竟牺牲你对谁都没有伤害。 职场有时候就是这么残酷。 “明哲保身”“从不站队” 几乎是不可能的幻想。想要两头都落好，通常是两头都得罪。所以，更不要试图在职场中将自己定位成老好人，那样你将会非常累。 当然，还有一个故事比 “没有站队” 更可怕，那就是墙头草。 就算是不幸站错了队，发现当前的队伍不够强大甚至寸步难行，也别轻易跳到别的队伍中去。对于随风倒的” 墙头草 “来说，如果自己的 “坏名声” 传出去，很容易被孤立，成为谁都不想要的 “枯草”。 这个墙头草的故事，我想例子很多，最有名的一个应该是李商隐了， 如果人生是一场牌局，李商隐起手就是顶天的顺子、四个 2、王炸。 然而他却打输了，还输的很惨。 由于故事实在有点太长，所以大家可以自行了解一下。 既然” 站队 “这样的潜规则在所难免，但是职场上嘛，我们总还是要挣扎一下，尽量选择合适的队伍去” 站 “。 那么，我们接下来就来聊聊怎么” 站队 “。 第一， 职场站队需要先观局。职场当中如果 “站队” 不可以避免，入队也不能盲目，特别是初入职场的 “新人” 来说，因为你不了解情况。 如果要破局，首先要静下心来观局。三国时期的刘备便是观局的高手，只有分析出” 天下大势 “，才有可能借势而起，活到最后。 职场上也要先分清派系、势力、权利、资源的对比情况，然后分析出站在哪一个队伍当中，对自己最好，对自己的利益最大，然后再投入队伍当中。 这里你可能要分析参考的包括队伍的办事风格是否与你相符，人脉资源如何，自己的发展和哪个” 队长 “的利益最匹配，自己的直属上司属于哪个队伍，甚至分析哪个” 队长 “最后获得胜利的几率更大。 同时，也要做好最坏的打算，就是自己所站的队伍失败后，该怎么保全自己，无论如何请给自己一头退路，这是职场生存的根本。 第二， 小兵站队要低调。不同的队伍之间难免会出现意见分歧，这时候做为小兵的你切忌过于高调。不要觉得自己已经站队了，就要肆无忌惮地站在自己队伍的立场上，全心全意为队伍服务。 要知道，职场当中不是所有事情都是非黑即白的，即使是队长之间也存在着各种各样的合作和互惠互利。” 两面三刀 “是职场上常有的情况。太过冒进一旦别人拿住了你的把柄，最后你在自己的队伍里成了抛弃的棋子 。 我们中国人相信中庸之道，别把话说的太死，因为，职场的科学就是 “永远有后路”。为了不给自己找更多的麻烦，表态时不妨中规中矩一些。 第三，职场站队要凸显价值。并不是说站队了就不需要工作了。我们讲的” 站队” 是面对职场上这种固然存在的文化，无奈之下的选择，初衷也是希望自己能够与同事和睦相处、融洽工作，能够在职场上更好地 “活下去”。 所以，做好自己的本职工作，让别人看到自己的工作能力，努力展示自己的优点，成为不可或缺的那种人。这样一方面在队伍中你能发挥更大的作用，也会由更好的上升空间，另外一方面，即使在 “站队” 失败以后，也会有其他上司 “慧眼识才” 的。 “职场站队” 确实是职场潜规则。我们要做的不是抗拒，而是需要承认它的存在。只有正视它，你才不被职场潜规则所伤害。“站队”，更不是为了伤害别人，而是自我保护的一种方式。 当然，如果有一天你已经有了站在一个队伍 “头排” 的实力，那么 “站队” 这件事对你来说，也不再是个难题了。 这一段说的有点沉重，更有点危言耸听的感觉。“站队” 并没有那么可怕，也更不是每个初入职场的人都会面临着这样的难题。其实站队也是一种社会关系的表现，而社会关系的基础原则是等价交换。 站队的前提是你具有交换的价值，或者交换的潜力，才会得到橄榄枝。 在你有能力得到橄榄枝之前，你还有时间去好好的 “观局”，更有时间去不断地提高自己的筹码。无论你是不是想站队，先让自己有 “站队” 的资格。 本文来自 风落几番 / 蚂蚁金服测试专家","categories":[{"name":"articles","slug":"articles","permalink":"http://arthurwang.top/categories/articles/"}],"tags":[{"name":"articles","slug":"articles","permalink":"http://arthurwang.top/tags/articles/"},{"name":"EQ","slug":"EQ","permalink":"http://arthurwang.top/tags/EQ/"}]},{"title":"15 “我不会，但我愿意学”","slug":"eq-15","date":"2020-01-19T09:57:55.000Z","updated":"2020-02-02T16:35:09.000Z","comments":true,"path":"2020/01/19/eq-15/","link":"","permalink":"http://arthurwang.top/2020/01/19/eq-15/","excerpt":"","text":"天才免不了有障碍，因为障碍会创造天才。——罗曼·罗兰 几天前面试的时候，有面到了一个女孩。整体上面试效果不甚理想，当我习惯性的最后问一下：你还有什么想要问的么？ 女孩很诚恳地表示：虽然我经验不足，能力不强，但是我愿意学！ …… 类似这样的话，我自己听过很多种版本： 在我年轻时候刚开始听到这种话，还是会觉得：啊，可能这个人很上进，很努力啊。可是仔细想想，这句话的潜台词是什么？它表示 “我这次搞砸了”、“我现在就是不会了”、“你愿意教我我就学”。 有的小伙伴会说了：风落，这不对啊，你前边不是还一直在说要学习，要提升自己么？怎么这会又出尔反尔了？ 我想说的是，在职场上，保持学习的态度和方向一定是好事，但你要明白不断说自己学习的姿态对不对。 这大约就是思维方式上的差距了。我们习惯于把这样的思维模式称之为 “学生思维”。当你还是一个学生的时候，如果你不努力，那么老师会过来催着你好好学习，这样的学习永远是被动的。 “虽然我现在不会，但是我愿意学啊，所以你就应该来教我。” 这就是最典型的表现，你不能说他态度不好，也不能说他不爱学习，事实上他往往还会表达出强烈的学习欲望。 但是，他们身上最大的问题在于，总是等着被教，总处于一种被动的状态当中，而非积极主动的去寻求问题的解决方案。 拜托大家醒醒，职场不是你的校园，老板更不是你的班主任，他们不会在拽着你向前进。但是一旦你掉了队，老板会很快把你抛弃。 再把话说重一点，这样的 “学生思维”，其实是一种 “弱者思维”。 所以在 “强者思维” 里，我们鼓励大家不断学习，是说你应该主动追求挑战并提升自己， 在你主动克服一个又一个难关的同时，达到学习提升的结果。 篇头故事里的小姑娘我没有通过，并非因为我没有恻隐之心，而是因为我觉得在求职的过程中，你需要展现的是你的能力、你的沟通技巧、你的技术实力，而不是你不会什么却告诉我愿意学。即便是你有很强的学习能力，也需要你在面试中通过表现让我感受到，而不是从你的嘴里说出来。 语言上的巨人，可能是行动上的矮子。 前段时间跟一个 HR 朋友约饭，也聊到了这样一个话题。 同样是一个毕业不久的小姑娘，同样在面试情况不佳之后跟 HR 求情：我家境不太好，读书也是靠助学金，来面试这个岗位，虽然没什么经验，但是相信我，绝对会认真学习，好好努力的。 我朋友被她的故事和诚意所打动，虽然没有相关经验，但是还是录用了她。 可是入职之后的情况和她说的完全不一样，每天都卡着点上班，甚至偶尔还会迟到，什么都不会也不主动去问有经验的前辈，关键是经常打盹、玩手机…… 某一次她的上级给她布置任务，让她完成一个简单模块的开发，她磨蹭到 deadline 最后一天提交上来，但是完全不能用。 她的领导也很生气，问她：你这么多天都做了什么啊？ 她很委屈地表达：我又没干过，你也不教我，我怎么可能会做呢？ 之前那个满口愿意学习，我会努力的小姑娘，就变成了这样一个消极怠慢一点都不努力的人。 所以，如果让我给大家一个建议的话，那就是：愿意学的，不如已经开始学的。 如果你即将面试或者将要去做一件你不太熟悉的工作时候，你应该怎么做呢？ 请教前辈：你可以找有经验的朋友、同学甚至是论坛上的陌生人求助，你可以得到一些指引和经验，也可以告诉你需要做什么准备，学习什么。 考虑下你之前的经历和即将开始的工作之间有什么联系，是否可以借鉴。 开始你的学习：无论是你要准备面试或者开始工作，首先都是做好功课，开始学习。没有人要求你一下子变成领域专家，至少你要让别人看到你在行动。 学会提问：实际上我之前有写过关于提问的文章，如果精炼一点来说，那么就是乐于向其他同事、上司求教，但是来问问题前一定要有自己的思考。如果我是被问问题的人，我更愿意听到你问的是 “如果我这么做，是对的么？” 或者 “我是这么做的，结果出错了，我查了一些资料，按照资料改了下，虽然不报错，但是执行结果仍然有问题”，而不是你来问我：“这个到底怎么做？” 对于很多实习生、毕业生或者刚入职场的同学来说，没有经验或者能力尚且有所不足是普遍存在的事实，但是这不能成为你的保护伞。 别让弱者思维毁了自己的前途。长期陷入弱者思维，会让我们变成一只鸵鸟，永远在逃避和抱怨。 斯蒂芬・金说：“地狱从来不是立即让你掉下去的，而是一点点吞没你”。 弱者思维也同样如此，一旦你习惯了它，它就会一点点吞噬你，直至你真的被生活打败，一蹶不振。 做一个强者，不惧挫折、富有智慧、善于学习又勇于改错。困难面前不要 “等一等”，而应该： I CAME,I SAW,I CONQUERED。 本文来自 风落几番 / 蚂蚁金服测试专家","categories":[{"name":"articles","slug":"articles","permalink":"http://arthurwang.top/categories/articles/"}],"tags":[{"name":"articles","slug":"articles","permalink":"http://arthurwang.top/tags/articles/"},{"name":"EQ","slug":"EQ","permalink":"http://arthurwang.top/tags/EQ/"}]},{"title":"14 “多干多错，少干少错？”","slug":"eq-14","date":"2020-01-19T08:57:55.000Z","updated":"2020-02-02T16:34:59.000Z","comments":true,"path":"2020/01/19/eq-14/","link":"","permalink":"http://arthurwang.top/2020/01/19/eq-14/","excerpt":"","text":"路漫漫其修远兮，吾将上下而求索。——屈原 不知道从什么时候开始，职场上有一个很通俗的观点：多做多错，少做少错，不做不错。 这个观点往往还是那些看起来很靠谱的“老同事”传达出来的，乍一听似乎有点毁三观，稍微一想却又有点道理。为什么呢？让我们来看看小灰的经历： 由此很多人，尤其是职场老人总结出了一条职场潜规则：多干多错，少干少错，不干不错。并且不断向外扩散，当做自己明哲保身的真理来用了。 那么这句话到底有没有道理呢？ 从短期利益上看，不犯错的确是可以规避很多错误带来的风险。这当然是没问题的，可是仔细想想呢？ 从长远的角度看，这样所谓的潜规则是荒谬的。 一、老板视角我们先来想想，老板为什么要雇佣你？是因为你不犯错么？不是吧。老板雇佣你是为了产出成果的。 如果你少干甚至不干，的确不容易犯错，但是也不会有什么成果，试想一下，你的老板为什么要雇佣一个“无法产出成果”的人呢？总不会是因为你长得漂亮或者长得帅气吧。 退一万步说，我们假设一个公司就是需要少犯错的人，每个人都遵守着“少做少错”这样明哲保身的规则，那么这样的公司会怎样？ 我想，这样的公司，办事没效率、拖拉、不靠能力靠关系，遇事能躲就躲，能甩锅就甩锅。日子久了，问题多多，能处理问题的人又都走了，自然也就很难长久。 所以，一个员工的价值不在于“少犯错”，而在于“多成果”。优秀的老板，衡量下属是不是合格，依据的绝对不是他犯了什么错误，而是他为公司、为老板创造了多少价值。 这也是资本主义经济观所决定的。 从这个角度上说，其实仍然有一种例外，就是那些所谓的“关系户”，他们可能是大客户的千金，某书记的宝贝或者是大老板的亲朋。同样，留住他们也不是因为他们少干少错，而是因为他们的存在能够带来更高的价值和成果。 二、个人视角如果说前边这一段还是从老板、从公司角度考虑哪种人才优秀，那么我们再从个人角度想想。 经验这个东西都是经历过、错过之后才能总结获取的。我们说一个人人生阅历丰富，绝对不是再说因为他富二代的身份一路顺风顺水，而是他浮浮沉沉的经历多；我们聊一个人恋爱经验丰富，也绝不是因为他跟女友长跑了几个“七年之痒“，而是因为他有了几段没有修成正果的恋情。 人嘛，只有错过，才能考虑为什么错，才会想办法避免这个错误。 到了最后，干多了错多了经验也多了，慢慢错误就变少了。这样的人，才能成为“解决问题”的人，才是职场上不可缺少的人，甜头在后边。 少干多错，就是因为做的少，经验积攒不起来。以前做这个可能会犯错误躲开了，那以后做这个还是犯错。总体来说，其实个人能力没有提升，这种人没有什么大用处，只能做小活，运气好可以这样干一辈子。 不干不错的，因为他什么也没有干，如果有关系，还能混混，没关系，迟早被踹了。 于是，最终获胜者还是多干的人，平庸的是少干的人，自以为聪明把自己坑了的是不干的人。 三、全局视角可能有的人还是固执地选择拒绝犯错，担心犯错的风险和结果自己承受不来，所以干脆选择少做不做。 大家跳出自己是个普通职员的角度，想一想，老板会赏识什么样的人？ 是默默无闻，既不知道他做了什么，也没看到他犯了什么错，更见不到他解决了什么问题的人？ 又或者是到处都有他的身影，偶尔犯一些错误，但是积极努力解决问题，不断提升的人？ 我想结果显而易见的吧。 在职场上就是这样，不要害怕出错。你出了错就会有人关注，我们本身一介小人物，能犯多大的错，给公司带来多大的损失？ 也许当你犯了错，并及时弥补甚至是改进，更能够得到领导的青睐吧。 那么最后，我也多说一点，“多做”与“少做”也有个边界，不要去做别人应该做的事情，更不要去尝试做自己尚且没有能力去做的事情，优先提升自己再多干多做。 不要相信所谓老人言“多干错，少干少错”，请不要做一个没有亮点、没有进步，只能抱怨和陷在基础工作的泥潭中无法自拔的人。 本文来自 风落几番 / 蚂蚁金服测试专家","categories":[{"name":"articles","slug":"articles","permalink":"http://arthurwang.top/categories/articles/"}],"tags":[{"name":"articles","slug":"articles","permalink":"http://arthurwang.top/tags/articles/"},{"name":"EQ","slug":"EQ","permalink":"http://arthurwang.top/tags/EQ/"}]},{"title":"13 该不该“巴结领导”？","slug":"eq-13","date":"2020-01-19T07:57:55.000Z","updated":"2020-02-02T16:34:49.000Z","comments":true,"path":"2020/01/19/eq-13/","link":"","permalink":"http://arthurwang.top/2020/01/19/eq-13/","excerpt":"","text":"青年是学习智慧的时期，中年是付诸实践的时期。—— 卢梭 前几天跟朋友聊天时，提到一个挺有代表性的话题： 工作里边是应该埋头苦干，还是应该多拍老板马屁巴结领导的好？ 去巴结领导，会不会有损自己的人格？ 随后，我跟很多学生聊了聊这个话题，突然发现，很多人在职场上都有这样的疑惑，所以今天，我就借这个机会跟大伙聊聊该不该“巴结领导”的那些事儿。 领导喜欢哪种人？ 在开始之前，我们有个问题：领导喜欢什么样子的人？ 我细致地回想了一下我自己的历任领导，不知道为什么居然不由自主的想到了历代君王，想到了和珅与纪晓岚。 答案就很显而易见了。领导大多喜欢两种人，要么忠心不二，句句都能说到领导心坎里；要么才华出众，能帮他干出成绩。 简而言之，要不是马屁精，要不就是实干派。 说到这儿，回到开篇的话题，好像埋头苦干和拍马屁这两种都可取啊？然而，这两种人要真想做到让老板喜欢，并不容易。纯正的马屁精，真心只靠溜须拍马就能够上位的人，即便你想学，也真的需要巨厚的脸皮和七窍玲珑心才行，不然的话，很容易变成一只跳梁小丑。 我也相信读到这里的大家，也应该更多是倾向于实干的人，不然可能也不需要来读“情商课”了。但是，古往今来，有多少“埋头苦干”的人，都因为太过于“埋头”，而错过了更好的机会。 是金子也不一定会发光 不知道哪个古人说的：是金子一定会发光的。职场上很多人都相信只要自己把活干好就可以了。 我曾经有一个小实习生，自己很努力，能力也不差，很多事情都做的还不错，可是在上级眼里，他永远不是做的最好的那一个，所以最终也没有能够留下。 临别时候，他很不爽的问我：哥，我事儿都做完了，问题都解决了，还要我怎样？ 是啊，还要我们怎样？你要知道，你的领导每天很忙，没有时间认真观察你做了什么，而领导的面前又排满了“争相表演”的同事，你等着让他发现你的好、你的成就，恐怕难上加难加难。 不是所有跟领导的沟通都是“拍马屁” 不得不说，我们身边永远不乏一些喜欢拍马屁的人，我们呢，一边痛恨他们的小人行径，一边又忍不住为他们用很小的代价获得最大的收获而羡慕不已。 但是，耿直的程序员们，容易走向一个极端，把所有跟领导的沟通都认为是拍马屁、是谄媚逢迎。 事实上，职场上跟领导的沟通是很重要的工作技巧。 《荀子·大略》有这么一个片段： “口能言之，身能行之，国宝也。口不能言，身能行之，国之器也。口能言之，身不能行，国用也。口言善，身行恶，国妖也。治国者敬其宝，爱其器，任其用，除其妖。” 如果翻译到职场上，那就是： 既能做好又能说出来的，这是国宝级的人才，需要大力提拔；能够做的很好，但是不擅长说出来的，是值得信赖的人；只能说不会做的，这种人可以做为工具来利用。而嘴上说着善实际上却为恶的，是对于团队有害的因素。 所以对于一个优秀的人才，能干固然重要，但同时还必须具备能说的本事。强调善用语言，也并不是提倡夸夸其谈，更不是否定行动的力量。一个优秀的实干派，也做到知行合一、言行并举。 做一个让领导欣赏的实干者 首先，必须把活干好干漂亮才行。你可以不做刻意迎上的小人，但是必须展现自己的真才实干。 接下来，就要巧妙地向领导展示你的成绩。这段其实咱们前边也聊过，就要“邀功”的技巧。 最后还有第三步，这里算是一种实干派“拍马屁”的方式，那就是归功于上。这个步骤叫做“归功于上”。大家想想，古代的忠臣典范，无论是刘墉还是纪晓岚，哪一个不是把事情全部做完，留下临门一脚给皇上踢出来，让功劳落到皇上的“圣明”之下。 即便你把功劳“归功于上”，其实你的领导很清楚功劳是谁打下的，也很清楚到底谁才能帮他获得好的成绩。 所以，回到开头的前提：领导到底喜欢什么样的人？ 除了马屁精以外，还需要懂的巴结领导的“实干派”，这里的巴结不是言语上的谄媚，而是能够给领导做出成绩的“巴结”。 那么，亲爱的程序员们，不要把“做”和“说”放到对立面上，两者是缺一不可的，“埋头苦干”和“巴结领导”是可以兼得的，即使是你对“巴结”这件事情嗤之以鼻，但至少要学会巧妙地处理工作中与领导的关系，不要因为“身能行之而口不能言”而让自己吃亏。 本文来自 风落几番 / 蚂蚁金服测试专家","categories":[{"name":"articles","slug":"articles","permalink":"http://arthurwang.top/categories/articles/"}],"tags":[{"name":"articles","slug":"articles","permalink":"http://arthurwang.top/tags/articles/"},{"name":"EQ","slug":"EQ","permalink":"http://arthurwang.top/tags/EQ/"}]},{"title":"12 “背锅”的艺术","slug":"eq-12","date":"2020-01-19T05:57:55.000Z","updated":"2020-02-02T16:34:40.000Z","comments":true,"path":"2020/01/19/eq-12/","link":"","permalink":"http://arthurwang.top/2020/01/19/eq-12/","excerpt":"","text":"人不可有傲气，但不可无傲骨。——徐悲鸿 职场上嘛，每个人都有个美好的希望，就是工作能够一帆风顺，但是现实中难免有各种意外，有一个很尴尬的情况，就是“背黑锅”。 我相信，职场上的小伙伴们，像上边小灰的遭遇，或多或少都遇到过。但是大多数时候，我们知道，明明不是自己的原因，至少你不是最主要的负责人，但是事情确实搞砸了，那么你该不该“背锅”呢？ 为什么有“背锅侠”？ 职场上总有那么一些人，他们不愿意承担责任，一旦出现了问题就“甩锅”给别人。让别人背锅，毫无疑问，这是一种逃避的表现，老员工让新员工背锅、上级让下属背锅，都是如此。 换个角度思考，如果你是一个公司的高层，当你的决策出现小的失误而造成了损失的时候，如果适时让一个下属“背锅”，公司也会对底层员工的容错率比较高，不会因此就直接做出强烈的处理措施。 没有人喜欢“背锅”，但是职场上，有些“锅”你不得不背，但是有些“锅”一定不要背。 我们要背什么“锅”？ 一、 领导的“锅”，不背也得背 这是一个发生在我身边真实的例子。作为一只职场普通员工，我们基本上是处于食物链的底端。如果领导让你做一件事，你确实按照领导说的完成了，但是结果却出了问题。这时候领导批评你，应该如何做呢？ 耿直的小伙伴或许会暴跳如雷，非要跟领导论一论到底是领导的错还是你的错。 换位思考下，如果你是领导，这时候会不会觉得丢了面子？退一万步，就算最后发现真的与你无关，是领导的责任，你觉得领导会对你有好感吗？ 这种情况下，恐怕忍气吞声是最好的选择。把郁闷和委屈都打碎牙齿往肚子里咽。你觉得领导真的不明白到底是谁的责任么？背下这个“锅”，很可能让领导对你另眼相看。 人嘛，只要是正常的人，都会有一些愧疚感的，当你为领导背锅而蒙受了损失的时候，领导也大多会用其他方式补偿你。当然，不排除有一些习惯了下属背锅的领导，那“为了生存”，这口锅也要暂时背下来，以观后效。 二、 团队的“锅”，可以抢着背什么叫团队的“锅”？比如说今天生产上突然出了问题，但是这个事情的责任人不太清晰，甚至根本就是集体决策失误导致的结果，不管是需求、架构、研发、测试和运维都漏掉了这样一种情况。 这时候原本就没有一个主要责任人，但是从领导角度看，需要把这个责任明确，才能够表达出从领导角度管理效率的优势。 这样的“锅”，可以背。 多年以前，我空降进入一家公司做为主管。老板呢希望我能够通过技术手段来整合公司里的研发测试体系，类似于现在所说的DevOps。但是吧，大伙知道，这种事情不是一个人、一个团队能够做成的，老板也没有给我对应的资源，其他团队也不大能配合我的工作。 做了一小段时间，我主动跟老板汇报的时候，主动承认了自己的工作错误，老板也非常生气，把我骂了一番。 当然被骂一定不太好受，但是后边的工作也有了转机。后来进行体系落地培训的时候，老板亲自站台，全公司人都到了；培训结束，老板也直言要求大家给予配合。这样复杂的体系建设工作逐步取得了一些成果，那个季度我不但没有因为被骂而被扣掉绩效，反而因为推动效果不错获得了老板的重视和奖励。 现在想想，如果在当时我汇报的时候不是主动“背锅”，而是“甩锅”：我能做的都做了，可是没有资源也没有人配合啊？ 那会怎样？ 我想尽管有可能当时回避了老板的斥责，但是结果上来看，老板会觉得我这个人能力不足。 主动把这个锅背下来，然后把老板的不爽转化为自己可以借到的“东风”，这才是对自己最有利的选择。同时，主动抢下这个“锅”，实际上也是帮老板解决了责任分配的麻烦，帮其他人避过了承担责任的风险，老板呢，自然也清楚明白，这件事情不是靠一个人就能“办砸”的，而且目前对他来说，最重要的事情，是解决问题。 三、 同级的“锅”，不要背在职场上，无论是功利的从职场利益来看，还是从对责任的明确清晰规则上看，明确是同级同事的”锅“，是最不应该背的。但是现实往往背的最多的是这种锅： 领导让小灰告诉同事小黄，本周把性能调优的分析过程和结果总结一下，发给其他部门。小灰通过口头传达了两三次，然而小黄还是忘了做。领导把他们俩叫出来问是怎么回事，小灰很委屈，说我传达完了啊，可是小黄却一口咬定说根本没有。但是公说公有理婆说婆有理，谁也说不清，谁也不服输。 断案嘛，靠的是证据，既然小灰没办法证明自己确实传达到了，这个锅只能他自己背。不但如此，跟小黄的关系也陷入了冰点，小黄还指责小灰为什么不多提醒他几次。 这是最常见的同级的”锅“，你背了，同事也不一定记你的好，他也未必觉得对你有所亏欠，甚至还会埋怨你。 所以我觉得，同事间的工作，不管是同部门还是跨部门，哪怕你俩坐的再近，也不要用口头传达的方式，尽量用文字保留证据，便于分清后续责任。这不是矫情，而是一种风险意识。 四、触碰底线的“锅”，不能背这里边的“锅”我们指的是一些“内部问题”，但是有些“锅”违反了公司的规章制度甚至违反了国家的法律法规，这样的“锅”，一定不能背。 五、带有坑的“锅”，学会躲职场里不排除有“小人”存在。他们不但不会主动“背锅”，还会制造“锅”让你背。 我曾经听学生说起过这样一个故事： 小 A 和小 B 是同一个部门的两个程序员，领导正在考察他们俩要把其中之一升职。小 B 心思机灵，所以故意某次找小 A 去喝酒的机会，诱导着小 A 吐槽在部门里一些不开心的事儿，并且偷偷录了音。 之后的情节相信不用我说，大家都能知道。小 A 被迫离职。 职场上不是不可以有一起吐槽的朋友，但是尽量不要是拥有共同利益的同事。友谊的小船不会翻，只是因为争夺的利益还不够大。君不见闺蜜因为男友反目、朋友因为工作结仇。 谨言慎行，不完全信任别人，不抱怨，说话留余地。这才是最正确的职场之道。 所以最后，我想跟大家聊的是：背锅也是一门学问，有的人会背锅，把锅背得漂亮，还能顺带解决问题；有的人只甩锅，看起来获得了暂时的安全，但是却换来了长远利益的亏损。不当职场炮灰，得从学会背锅开始。 本文来自 风落几番 / 蚂蚁金服测试专家","categories":[{"name":"articles","slug":"articles","permalink":"http://arthurwang.top/categories/articles/"}],"tags":[{"name":"articles","slug":"articles","permalink":"http://arthurwang.top/tags/articles/"},{"name":"EQ","slug":"EQ","permalink":"http://arthurwang.top/tags/EQ/"}]},{"title":"11 “996”的心酸与无奈","slug":"eq-11","date":"2020-01-19T04:57:55.000Z","updated":"2020-02-02T16:34:30.000Z","comments":true,"path":"2020/01/19/eq-11/","link":"","permalink":"http://arthurwang.top/2020/01/19/eq-11/","excerpt":"","text":"今天应做的事没有做，明天再早也是耽误了。——裴斯泰洛齐 “996” 的故事总是伴随着心酸与无奈。 老实说，这个话题不太好写。但是既然说了很多次，要写一个讲实话的专栏，对于程序猿群体的我们来说，“996” 还真的是一个不能不谈的话题。 罢了，反正已经说了那么多，不在乎多这么一趴，对不对？ 先解释一下 “996” 这个 IT 行业的专有名词：早上 9 点上班，晚上 9 点下班，一周工作 6 天。一般情况下并没有加班费。 真正把这个话题推上高潮的是一群程序员在网络上发起的 “996.ICU” 项目。 一时以来是众说纷纭，引发了强烈的议论。有支持 996 了，也有反对的。 支持 “996” 的表达的是 “996 是奋斗”，“趁着年轻还不多拼一拼”，“996 也是自愿选择的结果”，“不愿意干你别干啊”。 反对 “996“ 的很明确：“996” 的工作制违反了劳动法，把人变成了奴隶，996 也跟工作效率、成果、奋斗划不上什么等号。 我无意于在这场 “盛大” 的辩论赛事中参上一脚。只想说点心里话。 作为一个在互联网里混迹了多年的人，并且还有着各大一线互联网学生、朋友的我来说，“996” 并不是一件新鲜事儿，也不是现在才有的。实际上，大部分的一线互联网公司中，如果你能够保证自己是 “996” 的工作制，那无疑是幸福的。不信你可以就近到什么 “某宝大楼”、“某为办公区”、“某条大厦”，观赏一下彻夜通明的灯光秀就知道了。 其次，确实很少有公司明确提出 “强制 996” 这样的观点，大多数呢还是鼓励不强制。听起来 “996” 好像确实是一种自由选择的结果。实际上确未必。我在前边聊到 “上班第一天” 时候提到过，你可能有一个很喜欢 “加班” 的领导，甚至是一个自己不怎么样加班但却很喜欢 “你” 加班的领导。你的耿直到点下班往往会让你死的很惨。 更何况，在互联网公司里，真正 “鞭笞” 着大家不停加班的不是 “996” 的概念，不是奋斗精神，不是 “狼性” 文化 ，而是残酷的绩效考评。 比如现在通俗易懂的 “361”，什么意思呢？简单来说，就是强制规定所有的员工中，有 30% 的优秀，60% 的平庸，以及 10% 的 “废物”。每个季度评定的时候，各个部门都会有一定比例的 “垃圾” 指标。十个员工里必须选出一个 “不合格” 的垃圾，他会丢掉一部分奖金，丧失升职加薪转岗的资格等等等等。也就是所谓的 “末位淘汰”。 大家想一想，实际在一个公司里，大家的工作会不会有太大的区别，谁又能比谁好一点差一点呢？ 最终在领导或者老板的眼里，为了找出那个 “垃圾”，就多了一个公认的理由：不够积极。 什么是积极、什么是上进？还有比” 是否加班 “更能衡量这个的标尺么？于是职场的绩效考评，就变成一场加班奋斗战，只有你不断的努力，“996”、“9127”，只有不断跑下去，才能保证自己不是最 “垃圾” 的拿一个。“996” 成为了被迫、无奈的选择。 在 “996” 引发热议的时候，我跟朋友聊天时候大家都表示，虽然几多吐槽、几多愤慨，但更多的是无奈。无奈在于我们不愿意割舍 “996” 下的高薪而到 “955” 的公司里舒服的活着，无奈在于我们面临房贷、车贷、面临老人孩子家庭而无法让自己放松，也无奈在于软件行业普遍的 “996”，跳槽也不过是换个地方 “996”，更无奈于我们自己也并没有 “改变世界” 的能力。 用辩论圈很火的一句表达式：我们今天讨论 “996”，到底要讨论的是什么呢？ 如果说前边聊的是现实，那么接下来我们就聊聊在无奈的情况下，既然改变不了环境，就只好改变自己，做一个 “适者生存” 的人。 做 “无法替代” 的人如果你不想 “996”，又恰好不是 “富二代”，那么最重要的就是 “做一个不可替代的人”。 在我的身边，有两个 70 后的老朋友。一个是行业内低调的技术大佬，公司里很多架构、方案都依赖他的把关，甚至很多的底层框架修改都离不开他。另一个呢，技术不差兢兢业业，虽然不是加班最狠的，但是同样也会为了加班而拼命。 结局很残酷，前者工作量不大，没有事情几乎不会加班，朋友圈里到处留下他度假的身影，但是在公司的地位却水涨船高。后者尽管工作忙碌，晚上叫他聚会永远在加班，但仅仅因为一段时间孩子生病疏于加班，加上自身年龄也大了，就无奈的连续不合格，郁郁离开奋斗了多年的公司。 故事很真实也很典型，如果说起来也要替后者说一声不值，但是一个员工的核心竞争力就是你的价值。就像前边说的，如果老板觉得你的价值远远超过了你的薪水，并且别人还无法取代，那么什么 “996”、“361”，大抵是通通没有关系。 然而如果在老板的眼里，你的价值很容易取代，那么即使你不是最不努力的那一个，同样也很容易被 “垃圾”。 设法 “被动” 变 “主动”如果实在没有不可取代的本领，不得不加入 “996” 的大军，那么尽量的从 “被动加班” 变成 “主动加班”。在工作中找出自己有兴趣的点，不断放大，用加班的时间去完善、充实自己，为了更高的目标和更好的自己而努力。 说起来似乎挺鸡汤的一段话，翻译下来呢其实我想说，因为并不是每一天都需要 “996” 来完成你的工作，即使是忙碌的互联网大概每个月也只有一段时间真的是忙到不行。所以 “996” 的时间与其 “装作忙碌”，不如用来给自己找个兴趣点，在 “996” 里提升自己。 我有个不具名的朋友（之所以不具名就是因为我不想给他做广告！），他从最初的抵制加班，到后来利用加班时间去磨炼自己的技术能力，扩大自己的知识面，到现在已经摆脱了 “996” 的束缚，成了一个 “公众号” 的著名作家，收入秒杀我等一线 “码农”。 调整心态，适时娱乐当然，不是每个人都可以摆脱 “996” 的，这时候我觉得最重要的是心态。 除非你真正热爱这个工作，否则没有必要把工作当做你的全部（如果我的老板看到这句话，估计会拿菜刀追杀我…… 好在这章是收费的，我自信老板不会花钱看我的专栏 O (∩_∩) O）。那么保持平和，尤其不要在晚上加班时候跟自己过不去。 我身边确实有几个经历过办公室有人加班猝死的小伙伴，在我的了解里，大多数还不是因为过度疲劳，大多数都是心理压力的问题。所以，适时的排解心理压力很重要。 我会在固定的时间去到处度假，哪怕只是在海边边晒太阳边陪媳妇看一部轻松的偶像剧。也会在不加班的日子里，跟三五好友约着喝喝酒、吐槽吐槽工作。当然也尽量保持着自己的爱好，比如玩个手游、打打羽毛球、没事骑车去到处逛一逛。 热爱生活的人才更能保持良好的心态，从而用更大的热情在工作中发挥自己的能力，也能以更积极的状态面对 “996” 的来临。 本文来自 风落几番 / 蚂蚁金服测试专家","categories":[{"name":"articles","slug":"articles","permalink":"http://arthurwang.top/categories/articles/"}],"tags":[{"name":"articles","slug":"articles","permalink":"http://arthurwang.top/tags/articles/"},{"name":"EQ","slug":"EQ","permalink":"http://arthurwang.top/tags/EQ/"}]},{"title":"10 “我干得多，挣得少？”“薪资倒挂？”--谈谈职场薪水观","slug":"eq-10","date":"2020-01-18T12:57:55.000Z","updated":"2020-02-02T16:34:17.000Z","comments":true,"path":"2020/01/18/eq-10/","link":"","permalink":"http://arthurwang.top/2020/01/18/eq-10/","excerpt":"","text":"富贵必从勤苦得。——杜甫 这恐怕是我收到最多的吐槽内容了。无论是与学生聊天、在 IT 群里浪还是生活中和朋友吃饭，都会不断有这样的抱怨： “我同事天天什么都不干，一直打酱油，活儿都是我扛着，最近才知道人家工资比我还高！” “我们公司来了一个刚毕业的大学生，啥都不会，都得我教，但是他工资居然跟我差不多，这太不公平了！” “我天天干活，级别比她高，她就是会说话，结果月月薪水比我高，绩效还比我好，真是干不下去了！” 听起来这些抱怨都很有道理，如果设身处地的换位思考，我也会觉得 “真是不公平”，甚至像这些抱怨的主人一样，迁怒于吐槽中的其他人。 真的就这么不公平么？我先讲个故事。 熟悉我的朋友知道，我很喜欢辩论。大学时候呢，参加了不少的辩论赛，大学的辩论赛嘛，肯定跟奇葩说不一样，不会有现场观众投票，胜负就靠现场的五个专业评委来投票。 我有这么一个体验，只要投票之后结果是对方胜出，我第一时间就感觉评委不公平，只有当我们队获胜的时候，我才会觉得：今天的评委很公正啊。 职场上也是一样，大伙都知道现在各大互联网公司都在搞绩效评定，假如你的团队有 6 个人，领导呢要在 6 个人里评出一个不合格。那么无论领导的评判方式是什么、科学或者不科学，最终评定的 “不合格” 人选一定认为这不公平。 为什么？通俗一点说，我们叫：pg 决定脑袋。你站在什么立场上，就支持什么。 那么包装一下，这是因为很多时候，我们口中的公平其实只是基于自身的立场的愿望而已。这种愿望对你来说是一种公平，但是对其他人来说，又是另一种 “不公平”。 所以，关于挣多挣少这件事而言，问题的核心在于：老板认为你价值多少。 换句话说，职场里薪水的公平就是：你觉得 “你能值多少” 和老板认为 “你实际价值多少” 是否可以达成统一。 通俗一点讲，那就是我们在谈入职的时候，你认为自己值五万块，老板也觉得你可以值五万块，这样双方达成了统一，你就以五万的月薪入职了。 那即便后边面试另外一个员工，不管他的学历背景如何，哪怕你们是同一岗位、完全做一样的事情，那么，即便他在这个 “价值问题” 上跟老板在 “六万” 达成了一致，实际上也跟你没有关系。 问题的关键在于，你的同事并不参与你和老板之间的价值判定。 也就是说，不管你的同事他挣了多少钱，干了多少活，对你来说都没有任何的影响。那么当你发现自己的收入比同事低的时候，如果表现的愤怒甚至开始敌视自己的同事，这显然是把情绪放错了地方。你真正需要谈判的对象是你的老板才对，而你把过多的精力浪费在跟同事较劲上，这对你来说不会有任何的帮助…… 本来呢，这一番到这里可以画上一个终止符了。但是相信还有很多人忿忿不平，把这个态度转向了老板，这次的核心吐槽点在于：如果我离职了，你再难花同样的薪水请到一个这么懂业务能力还这么强的人了！ 这句话对不对？我觉得绝大多数情况下没问题。目前，很多公司都会出现工资倒挂的情况，新人入职工资可能跟工作了几年的老人差不多，甚至出现比老人工资还要高的情况。但是为什么很多公司宁可高薪去聘请新人也不愿意给更熟练更有经验的老人涨薪呢？ 我们换个角度吧，假设你现在不再是那个满腹抱怨薪资不公的老人，而是一个公司的老板。 首先，对于新人的 “高工资”，是你一个老板愿意给出来的么？你真的觉得一个刚刚毕业的研究生值那么多钱么？未必。 一般来说，社会上的招聘或者是应届生，他们的工资并不是完全由老板说了算的，主要要看行业里的工资水平。其他大公司都开出了年薪二十万，你只给月薪 10k，那想必是没办法招到人的。 那有的同学要问了：别招聘不好么，稳定住现在的老人多好？ 如果你问出这个问题，那么我要对你说四个字：鲶鱼效应。 每个公司都不断的需要新鲜血液，来激发内部员工的能力。一家公司一旦长时间无法招聘到新员工入职，基本就会不可避免的走向衰败。 所以，这个时候，即使是新人的工资水平超过了公司内部的薪酬设计，往往也只能咬牙录用。这样的 “高工资”，是作为老板的你 “被迫” 开出来的。 于是，又出现了一个新问题：既然新员工的薪水这么高，是不是应该适当提高老人的薪水？ 站在一个打工者的心态，自然是。但是现在你是一个老板。 我们也发现，实际上，为了节约成本，公司内部的薪酬调整频率和幅度，远远低于市场上薪资的水平。WHY？ 因为每个员工离职是要付出成本和承担风险的。 举个例子来说，如果现在有一份新的工作，薪水比你现在提升 20%。很多人还需要考虑一下。考虑的是什么？ 就是 20% 的提升加上未知的工作风险和稳定的工作环境、原公司积累的人脉、熟悉的工作方式之间的价值是否平等。 如果这个时候，原公司跟你说：别走了，我给你涨薪 10%。我相信，如果你只是因为薪水问题想要离职，那么很多人会选择留下来。 那么反正少给你开 10% 的工资，你也不会离职，那为什么不把这部分成本节省下来，转化为公司利润呢？ 所以大家是不是可以稍微的理解了我们今天这趴的主题：“干得多挣得少” 与 “薪资倒挂”。 有很多人问我怎么样才能尽可能避免这种情况 ? 最后我有三个建议可以给到大家： 正确评估自己，知道自己到底值多少钱 职场的薪资公平在于你对自己的评估和老板对你的评估。那么当你觉得自己的评估是 3w 而老板实际给你开的薪水只有 2w 的时候，你完全可以主动提出涨薪的要求。 前提是：你要合理客观地了解自己的价值和你在老板心里的价值底线，从容的与老板进行二次谈判。你提出涨薪的理由应该是 “我能为公司创造更多的价值” 而不是 “别人比我工资高” 或者 “我觉得我应该赚更多”。 做 “不可或缺的人” 一般来说，真正那种不可替代的员工才能够最好地捍卫自己的利益。因为公司无法承担你离职带来的后果。 但是同样要合理评估自己，毕竟很多时候，你以为的 “不可或缺” 未必是老板心中所想。 不要抗拒跳槽 从结果来看，绝大多数跳槽者都能得到收入水平的显著提升，而且适应一个新的工作环境远没有你想象中那么困难。 本文来自 风落几番 / 蚂蚁金服测试专家","categories":[{"name":"articles","slug":"articles","permalink":"http://arthurwang.top/categories/articles/"}],"tags":[{"name":"articles","slug":"articles","permalink":"http://arthurwang.top/tags/articles/"},{"name":"EQ","slug":"EQ","permalink":"http://arthurwang.top/tags/EQ/"}]},{"title":"09 从被抢功到会邀功","slug":"eq-9","date":"2020-01-18T11:57:55.000Z","updated":"2020-02-02T16:34:03.000Z","comments":true,"path":"2020/01/18/eq-9/","link":"","permalink":"http://arthurwang.top/2020/01/18/eq-9/","excerpt":"","text":"与有肝胆人共事，从无字句处读书。——周恩来 接着顺着上一篇的尾巴，从抢功我们聊一聊邀功的故事。 我跟很多在职场上郁郁不得志的朋友都聊过，发现他们在工作里有这么一个美丽的“误会”： “只要把活干好，领导自然会看到我的努力” 这当然是一个很美好的愿望，但现实中却被无数的例子打脸。 职场上还有这么一句话：累死累活的，干不过做 PPT 的。 想想吧，这还是一件挺无奈的事情。你有出色的创意、周密的设计，辛辛苦苦几个通宵，做了很多准备的方案，到了开会时候，就因为 PPT 做的不好而被否决；你有优秀的能力、丰富的成果，累死累活，到了汇报的时候，却被天天混日子的同事一张漂亮的 PPT 抢了功劳。 这件事确实不公平，但是真的就不合理么？ 这其实是一个对于“工作”的误区。一件事情，只要把它拿到职场上，那么什么情况下才叫完成？只有当你把工作成果展示出来，才算完成。 否则，就是行百里者半九十。 那么，“汇报”就是一份工作中重要的组成。如果你想成为一个优秀的职场精英，或者往小一点说，想要工作的稍微顺心一点，那么就一定要巧妙有效地汇报你的成果。 永远记住，善于汇报、长于邀功一点都不可耻，自命清高还怪命运不公才可悲。 学会邀功，记得要在你汇报之前弄清楚一件事：虽然你不是老板，但是你得明白老板想知道什么？ 否则你空有一箩筐的成绩、满肚子的才华，正式场合里却表达不出来，岂不冤哉？ 举个例子，小灰呢在一家互联网公司工作，主要负责某一个模块的开发以及一些生产问题跟踪和处理。某一天，老板正好路过他座位的时候，随口跟他聊了两句。 老板：你平常工作都是什么啊。小灰：也没什么特别的，就…有需求的时候就做一做需求，解决一些生产上问题，改改bug什么的。 小灰呢，也是没有准备，性子耿直加上猛地被问有点发懵，就这样回答了。老板当时什么都没说，但脸色已经不太好看了。 这个回答确实让人无法满意，因为听上去，你的工作特别容易，而且可能还挺“闲”。 可是如果小灰这么回答呢？ 这么一看，还是这三项工作，当补充进来几个需求、几个投诉、几个 BUG 这样具体的数字的时候，显得很专业和详细。 这就是汇报工作中的技巧中，最重要的一点，要量化工作成果。毕竟具体的工作事项太过琐碎也太笼统，而量化则工作量与工作成果最直观的表现形式，把“我做了什么”变成“我做了多少”。 告诉老板你创造了多少价值 经济学中有投入和产出这样两个概念，投入和产出在一定程度上是成正比的，所以说公司在你身上投入多少资源，你所能创造的价值也就有相应的反馈，这是其一。其二，随着你在公司的年限不同、岗位不同，所扮演的角色也必然不同，对公司创造的价值也会不同，包含所能给公司创造的利润、对周边同事，包括上级、下级、平级以及客户所带来的积极影响，这些潜在的价值等等。这些东西是没办法去量化的。 总结下来有这么几点： 只有你创造了价值，有产出，公司才会反哺你更大的投入； 尽管真正的价值很难量化，但是老板其实不在乎你干了多少活儿，吃了多少苦，而是关心你创造了多大价值。 我在职场上看到很多程序员们，在工作汇报的时候会出现很多细节。比如解决问题的细节、技术上的细节、架构上的细节等等。这些描述很好，如果是给你的同行来分享，或者拿到一个什么什么大会上去，那可能会让大家非常追捧。比如这样一个主题：我们是如何解决 90 秒 100 亿的性能瓶颈的？ 但是老板，他可能并不在一线岗位，这些技术细节，他不关心也听不懂。出于礼貌，他不好打断员工的汇报，但是结果可能不会太好，他根本 get 不到你的汇报里到底牛逼的点在哪儿。 *老板想听到什么？ *我们又一次回归了开头的问题。 老板想知道的是最终的结果。所以从他的角度，听到“全天成交了 2684 亿”会比解决性能问题更关注一点，又或者听你的一遍汇报，只能记住“90 秒 100 亿”。 但是这没办法表达你的成果，这些数字不完全是因为你技术上的优化达成的啊。怎么办？ 用对比的方式。 告诉老板，我们通过技术手段解决了支付中的性能瓶颈，将支付失败的概率从百分之 30 降低到百分之 15，由于成功率的提升，也让今年双十一的破百亿速度从前一年的 2 分钟变成了今年的 90 秒。 是不是更有冲击力了？老板也能更形象的 get 到你们团队的牛逼之处了。如果这时候再辅助以一些图、数据图表等，就会有非常好的汇报效果了。 最后，我要说，所谓的“累死累活的，干不过做 PPT 的”只不过是由于你没有掌握要领，这并不是说要你去把 PPT 做出什么惊艳的效果，只要你掌握到“老板想知道什么”，投入一点点精力在你的汇报上，那么你就很容易做到一个“会邀功”的人。 这在现在的职场中，很重要。 本文来自 风落几番 / 蚂蚁金服测试专家","categories":[{"name":"articles","slug":"articles","permalink":"http://arthurwang.top/categories/articles/"}],"tags":[{"name":"articles","slug":"articles","permalink":"http://arthurwang.top/tags/articles/"},{"name":"EQ","slug":"EQ","permalink":"http://arthurwang.top/tags/EQ/"}]},{"title":"08 从“我干活，你抢功”聊起之“抢功精同事”篇","slug":"eq-8","date":"2020-01-18T07:57:55.000Z","updated":"2020-02-02T16:33:53.000Z","comments":true,"path":"2020/01/18/eq-8/","link":"","permalink":"http://arthurwang.top/2020/01/18/eq-8/","excerpt":"","text":"机遇只偏爱那些有准备的头脑。——巴斯德 书接上文，上一回我们讲到真正的 “抢功” 实际上只发生在同事之间。就像前边说的，平级的同事之间我们不会太涉及共同的利益、共同的目标以及互利互惠的关系。就像小灰这次遇到的情况一样： 这就是在很多公司里都存在，越是大公司情况越多，手段更隐蔽的一种令人非常厌恶的人 —— 抢功精。 抢功精们总是观察细致，见缝插针，趁你不注意就把你的功劳盗取，然后转眼谄媚地跑到老板面前邀功。抢功精们精于算计，手段高超，抢功劳抢得滴水不漏。 既然不是你的领导，就没有互惠的必要，所以难免让人心生厌恶，毕竟没人愿意自己辛苦的成果被别人抢走。奈何这些 “抢功精” 本领太大，总是在你不经意间就逃出了你的视线，出现在了老板的面前，展示着原本属于你的东西。甚至有时候让我们感觉，这遇到的绝对不是一个程序员同事，大约应该是某个 “江湖大盗” 易容过来的。 摆在你面前的有这么几个选项： 默默忍受 向老板澄清 以牙还牙以眼还眼 联合他人，共同进退 辞职走人 如果是你，你会怎么做呢？ 第一、控制自己的情绪我们在职场上，不可避免地会遇到小人，像 “抢功精” 这样的小人虽然令人厌恶，但至少不是直接伤害你的那种。大家也可以理解，任何人知道自己的功劳被人抢走了，情绪一定会不够稳定，如果性格再稍微火爆一点，很容易就当场爆发出来。 但是请尽量克制一下自己，控制自己的情绪，冷静下来。即便你很有道理、你很正确，即便你能够确保其他同事和领导能够了解真相，也千万不要在大庭广众之下大发雷霆。因为这不但不容易为自己伸冤，还容易被打上 “脾气差”、“难相处”、“没情商” 的标签。 第二、判断形势既然不要迅速反击，那么接下来就冷静下来好好判断一下现在的局面。这有点类似于我们打篮球、下围棋，再通俗一点就是打麻将。不要因为自己已经输了一局或者落后了一点就着急上头，职场上很重要的一件事情就是判断。 判断什么呢？判断现在这件成果被抢功的影响范围。如果影响范围只在少数几个同事圈中，那么就大可以轻松礼貌地当着 “抢功精” 的面澄清真相，相信他并不会反驳什么。 但是如果抢功精已经在老板面前展示过，并且老板和同事都认为是他的功劳的时候，“澄清” 这件事就并没有那么简单了，因为先入为主的思维，除非你在这个成果中留下了他人无法知晓的底牌，否则很难轻易反击。 第三、制造舆论，掌控人言既然所有人都把这份功劳归于了抢功精，那么解释都是徒劳。但不代表就无休止地忍让了。默默忍受，只会让抢功精盯上你，谁让你不说话好欺负呢！选择负气离开，那更是毫无意义，因为你还会在另一家公司遇到其他抢功精。 那么适合的反击形式就是过一段时间，找一个恰当的时机，把这些事情和同事说一说，这里注意啊，“说” 是个中性词，不要把 “说一说” 变成祥林嫂的唠叨，也不要过多抱怨批评，而是以说笑甚至是提醒的方式讲述这个事情。 在这个方面红楼梦里的王熙凤算是个中高手，比如： 薛姨妈听后便道：“昨日晚上，我原想着今日要和我们姨太太借一日园子，摆两桌粗酒，请老太太赏雪的，又见老太太安息的早。我闻得女儿说，老太太心下不大爽，因此今日也没敢惊动。早知如此，我正该请。” 凤姐儿笑道：“姨妈仔细忘了，如今先秤五十两银子来，交给我收着，一下雪，我就预备下酒，姨妈也不用操心，也不得忘了。” 这样的玩笑话看似是在逗乐，实际上是当着大家的面揭露了薛姨妈小气又虚伪的嘴脸。 通过一些说笑的方式，借用一些细节，甚至如果你确认 “抢功精” 对于实际的成果并不了解的话，你完全可以找到恰当的时机在某一次合适的场合在老板和同事面前探讨： XXX，我们之前实现过这个类似功能啊，你还记得么？ 无论是老板还是 “抢功精” 接话都可以顺理成章的把话语权接过来，暗示当初的成功是你主要完成的，让别人看清事情的来龙去脉。要知道别人的口风可是件杀伤力很大的武器，要不了多久大家就知道是啥情况了。 第四、抱团取暖“抢功精” 一般不会只坑你自己，他们的战斗力一般都是辐射所有看起来好欺负的人。所以，你可以观察下，也可以多找团队里的一些关系不错值得信任的老人聊聊。 这未必能改善你和 “抢功精” 的对立关系，但是一方面，可以为融入老人的圈子找到了一个共同的话题；同时，也能更好的达到掌控舆论的目的。 当然，不要指望别人可以路见不平拔刀相助，他们最多会抱有同情，更好一点会给你一些劝慰和帮助。 但是就像 “上班第一天” 时候聊过的，一个团体、一些有经验的老人的帮助就是你在团队中最宝贵的资源。 第五、吃一堑长一智被抢功精坑过一次就够了，凡事都要留一手，防患于未来。 学会保护好自己的东西，一旦想要展示，就一定要在团队大多数人都在的公开场合。即使私下里需要和其他人一起商量，也不要把所有的点都说出来，万事留一线。最后，保留一些核心的可以证明有且只有你才知道的核心 “证据”。 到时候，抢功精自然会望而生畏，即便还有人抢功劳也有反击的证据。 不管最后的结果怎么样，能给抢功精一些教训最好，但是也别把心思都放在上面，最主要的还是做好一件事：认真工作并学会表达。 好好工作，做出好的成功，这是我们很多人的本心，我们也相信路遥知马力，日久见人心。但是在当前这个时代，“能做” 很好，“只做不说”，不懂为自己 “邀功”，事实上这就是我们的不足之处。 这就好像我喜欢一个女孩子，但是呢我始终默默关心、嘘寒问暖，相信有一天女孩一定能看到我的真心，一定会被我感动，主动投入我的怀抱。PS: 老婆，我真的就是举个例子…… 这样的故事只会出现在言情剧里，“爱要大声说出口” 才是这个年代年轻人应有的表达方式。所以，不要期望我勤恳工作，终有一天被老板发现：啊，原来是你一直在支持我！我要给你升职、加薪、让你做总经理、迎娶白富美。 不可能的好吧！所以，学会表达自己，让大家知道你做了什么，让别人知道你的重要性，让老板看到你的开口。 接下来只要你完成了工作，又能处理好与同事的关系，就一定能够得到同事和领导的认可。到时候，别人就是想抢你的功劳，也没有什么机会了。 本文来自 风落几番 / 蚂蚁金服测试专家","categories":[{"name":"articles","slug":"articles","permalink":"http://arthurwang.top/categories/articles/"}],"tags":[{"name":"articles","slug":"articles","permalink":"http://arthurwang.top/tags/articles/"},{"name":"EQ","slug":"EQ","permalink":"http://arthurwang.top/tags/EQ/"}]},{"title":"07 从“我干活，你抢功”聊起之“抢功劳的上司”篇","slug":"eq-7","date":"2020-01-18T04:57:55.000Z","updated":"2020-02-02T16:33:43.000Z","comments":true,"path":"2020/01/18/eq-7/","link":"","permalink":"http://arthurwang.top/2020/01/18/eq-7/","excerpt":"","text":"书籍乃世人积累智慧之长明灯。——寇第斯 这次是个比较“丧”的话题，在职场上，似乎每个老实人都容易被“抢功”。上面小灰的经历并不特殊，反而非常常见。在感觉自己的功劳被他人窃取的同时，还大大打击了自己的工作热情。 开篇词就有这样一个“抢功劳”的故事，但是似乎又跟小灰的经历有所不同，实际上，这里边最大的差别在于“抢功”的人到底是你的同事，还是你的领导。 我们不妨先从“抢功劳的上司”说起。 我很理解很多像小灰一样的同学的感受，我自己也有过这样类似的经历，可能这时候如果有现实中熟悉我的朋友，很可能听到我吐槽过这样“抢功”的事。 但是不得不说，仔细想一下，很多时候我们对“抢功“这件事情有那么一点点误解。 别激动啊，我不是要替抢功的领导说话，我们冷静下来想一想，对于管理者来说，他的职责是啥？ 对于一个管理者来说，他的本职工作就是调配相应的资源，以帮助下级产生工作成果。 什么意思呢？就是说，他可能一行代码都没写过，当然甚至都不会写，但是他的任务就是分解工作、协调资源，经过他的沟通和从中协调，让部门或者是小组里的人员完成上级下达的命令，获得工作成果，这本来就是他的工作范围。 从这个角度来说，他去邀功没有错，甚至另一方面说，他的功劳，某种程度上也是在替整个部门“请功”。 我相信，可能会偶尔有一些傻主管、傻上司，但是能在一个公司里做到老板这个级别的，很少还有傻的了。你觉得他会不清楚这件工作的完成离不开你们所有人的通力协作？但是你觉得老板会到你们的办公室里一个一个夸过来么？显然不。 所以，他在老板面前“抢功”实际上也是让老板知道，“我们的部门”工作很出色。只不过，更优秀一点的管理者会愿意在老板面前替自己的下属表功。有些人呢可能为自己考虑得更多一些，所以更多的是强调自己的功劳。 当然我们知道，能替你去表功的领导会很受大家欢迎，但是即使只是强调他的功劳，至少也让你的老板知道你的部门对公司做出了哪些贡献，所以可以算是合格的行为。 更可怕的是什么？更可怕的就是你遇到一个只懂“埋头干活”，不会“表功”的上级。因为作为管理者，却无法有效地与上级进行沟通，只会连累得整个团队默默无闻。曾经若干年前，我第一次做管理的时候，就是这样的。我确实不清楚应该怎么样告诉大家：我们团队非常出色。我觉得把现有的工作做到最好就 OK 了。这是一个程序员的思想，不是合格的领导。 明白了这些道理，我觉得很多时候，遇到“抢功劳”的上司，你首先需要的是把心态摆正。归根究底，你的上级再怎么邀功，最终实际的功劳一定是整个部门的。 有的同学说了：我就是觉得为啥我干的活儿，都让他给说了，心里怎么就是过不去这个坎。我相信这么想的大有人在，所以我们接下来聊聊另一个话题：向上管理。 向上管理？是不是很多人都觉得只有领导管我的份，我还能管领导了？其实不然，我们上一趴也说过，其实想办法跟领导站在同一战线、保持利益一致就是向上管理的基础。 如果你希望自己的工作成果获得更好的展现，赢取更直观的认可，首先要做的第一件事情，就是不要把你的上司当做敌人。 千万不要为了把你的上司“比下去”而去表现的更“积极”，更“突出”，你的老板真的未必会因此对你另眼相看，但你一定会刺激到你的直属上司。 我曾经年轻气盛的时候趟过这样的坑，结果就是一拍两散，自己的工作变得非常困难。甚至说你的绩效、评价都因此受到影响。 实际上，从工作角度来说，你和你的领导根本不会有什么利益上的分歧。那么我们实际上要跟领导保持这样两点关系： 通过你的工作，能够让他获得更多的成绩； 让他认识到，更充分地展示你的能力对他自己也是有利的。 相比之下，第一点似乎比较容易，而第二点给大家的感觉就比较难了。事实上也未必，想要做到这一点，用一句话来概括，那就是：Be An Expert ! 我估计有同学已经骂出声来了：风落，你居然还开始拽英文了！咱们解释一下怎么做个专家。做一个优秀的专家，除了能够“解决问题”，还需要具备“解释问题”的能力。所谓的解释问题，就是要把你的一些架构设计啊、解决方案啊等等专业的问题通俗化，让其他人也能够听懂，能够参与。 这样最大的好处就是让你的上级可以参与一些技术性问题的讨论，并且给出自己的意见，同时你又可以把这些意见转换成为技术性的语言，实践在项目中去。如此一来，这个干出来的成果，就也同时有了领导的功劳，领导也更能认识到你的能力。 够了么？ 并不，这只是先让他认识到你的能力，直视你们互惠互利的实际意义。怎么才能让你在工作成果上有所体现呢？ 我觉得这个关键在于对技术细节的包装。 领导虽然很多是做管理工作的，甚至不太懂技术。但是他在汇报的时候，也愿意让老板看到这次汇报的专业性。而你完全可以从专业角度，针对这个项目主动给领导制作一份总结分析。这样对于整个团队的成果汇报有很好的帮助，能够有效提升整个团队的表现评定。 更重要的是，这样可以把问题从“浅显”的表面，引向“专业领域”，这时候更能凸显你这个“专家”的重要性。再功利一点，你来想一想，当你的领导发现自己的报告里需要有一部分很专业的内容，汇报给老板有利于自己的利益，但是呢，他自己又对这部分不太够擅长的时候，自然就会想到带上一位“专家”…你懂得。 所以你看，所谓的向上管理不是让你命令领导或者告诉领导应该怎么做。而是在共同利益的前提下，帮助你的领导获得一个最优的解决方案。 除了“抢功”的故事，在实际职场中，绝大多数与上级相处有关的问题，都可以应用这样的逻辑来获得解决：找到相同的利益，再去思考如何做。 职场上，真正的“抢功”实际上只会发生在平级的同事之间，我们下一趴再继续聊。 本文来自 风落几番 / 蚂蚁金服测试专家","categories":[{"name":"articles","slug":"articles","permalink":"http://arthurwang.top/categories/articles/"}],"tags":[{"name":"articles","slug":"articles","permalink":"http://arthurwang.top/tags/articles/"},{"name":"EQ","slug":"EQ","permalink":"http://arthurwang.top/tags/EQ/"}]},{"title":"06 “什么都不懂，还爱瞎指挥”--外行领导内行那些事","slug":"eq-6","date":"2020-01-17T07:57:55.000Z","updated":"2020-02-02T16:33:29.000Z","comments":true,"path":"2020/01/17/eq-6/","link":"","permalink":"http://arthurwang.top/2020/01/17/eq-6/","excerpt":"","text":"低头要有勇气，抬头要有底气。——韩寒 职场上，非常让人尴尬和纠结的一个局面就是遇到一个“外行领导”。如果说这个领导吧虽然外行，但是人还好，尊重下属的意见，从善如流，那还一切好说。但是就怕领导明明自己是外行，但是不知道是盲目自信还是死要面子，到处“瞎指挥”。 做为下属来说，往往真的是有意见也不敢提，但是万一你没有按照指挥搞定，那背锅是一定的。 首先要跟大伙说的是一个悲伤的故事，那就是“外行领导内行”在IT圈里真的一点都不少见。 所以，今天，我们就来聊聊，如何与一个外行领导相处的那些事儿。 01 不要说“你不懂” 小灰在一家 IT 公司负责软件开发的工作，已经有了三年的经验，虽然不算高高手，但是业务能力强，他的领导是一个纯管理人事，完全不懂程序的人，更别提 Java 了。但是他有一个特点，就是非常擅长空话、套话，能够把东西吹上天，但是解决不了任何实际问题。 开始还好，时间一长，小灰正常的工作总是被领导打断、还总是指手画脚地告诉小灰你应该这么做那么做，积怨逐渐加深。 终于有一次，有一个非常紧急的业务修改，本来小灰已经订下了方案，正要开始搞起，领导突然召集大家开始开会，讲这个业务修改的内容，甚至还要给小灰他们订方案，review 设计。小灰当时很着急，于是对领导吼了一句：“你又不懂！” 加上之前的积怨，只得离职了之。 我们抛开这个故事，想一想为什么会有外行领导内行这件事情发生呢？ 实际上从公司角度来说，人尽其用才是最好的。你的技术非常牛，那你就应该在技术的第一线；他的管理沟通能力出色，那他可以成为一个管理者。所谓的“专业能力”从来都不是任命管理者的第一优先考量。 事实上你想一下，万一真的你的老板是个专家？那你就会发现，大概率你的工作会变得更加艰难，因为人家什么都懂，那你就很难解说自己的想法和设计。于是，你就变成了一个纯粹的执行者而很难得到提升。 反过来，如果你的领导是个“外行”，这才是互补啊，也才是你们合作的前提。试想一下，我们程序员为什么总是很苦逼？很大原因上就是因为不会说，不会营销。职场上的所谓的“大话”、“空话”并不一定完全没有意义，这也是你一个技术人所欠缺的，而这，也往往是这样领导所擅长的。 如果说认识到一个人的优点是合作的基础，那么另外一个道理也很显而易见： 任何良好的沟通，都不应该从“指责”对方开始。 “你不懂”三个字，绝对是打破一切美好表象的“利刃”，而且这样崩盘的上下级关系，百分之一万是难以破镜重圆的。道理很容易明白，没有人愿意被别人指责，尤其是被自己的下属。 我们不排除有人确实对自身能力缺乏评估，不知道自己“吃几碗干饭”。但是，你扪心自问一下：刚刚这样的领导是真的不清楚自己的能力么？一个能被任命为管理者的人，对于自身能力水平难道没有一点概念么？ 因此，当你真的遇到一个不懂装懂，指手画脚的领导的时候，我们来一起想一下，他为什么要这样？ 很简单，为了维护自身的权威。 OK，从更高的角度来看，这不是一个好的管理者所应有的行为。我们也更愿意、更希望有一个“从善如流”的管理者，但是尽管于理不通，但却是人之常情，尤其是我们发现有不少领导会这样。当你对这个局面无从改变，你应该做的不是吐槽、不是抱怨，更不是指责。 我的建议是这样的： 不要指责，而是建议； 不要突出“我”、“你”，而是多站在对方的角度上，用“我们”来开始讨论； 当冲突点无法调和的时候，尊重领导。 02 “不行”和“更好” 小灰是一个资深的 Java 架构师，某一次在一个项目会议上，老板突然提出了自己的方案。小灰从自己的专业角度分析，觉得这个方案完全不可行，于是站出来提出： 我觉得这个方案不行 。领导当时什么都没有说，但是不久以后，借由一个其他的事情把小灰调到了其他部门。 换个角度想想，如果你是那个提出方案的人，而突然某一个声音冒出：我觉得你说的不对。你心里是什么感觉？ 当然没有人喜欢被否定，更何况是一个需要维护自身权威的领导。 对待外行上司，内行员工你当然比他更专业，更优秀，但也不能摆出唯我独尊的优越感，觉得自己是业务精英，舍我其谁，这样只会让自己陷入难堪的境地。 在上下级关系里，我们天然就是处于弱势，你和领导的话语权本来就不平等。一个否定的开始，必然带来不欢而散的结局。 真正有情商的人，不会直接反驳对方的观点，而是通过肯定对方，建议对方的方式。 比如，非常常见的一个回复方式就是：我觉得这个方案很 ok，另外我有几个小建议，希望能跟您讨论一下。 不要冷冰冰地回击领导，给他留个面子，留一定的缓冲空间，让他能够停下来，听听你在说什么，也给他一个机会纠正自己。 同样，如果这个人换成你的下属、你的同事、甚至是一个陌生的场合陌生的人表达的一个观点，那么也请你站在一个有情商的角度，不要反驳，而是探讨、建议。 实际上，在生活中、在工作中，极大的可能，你并不想全盘否定对方。更多时候大约只是某一个点或者某几句话会让你感到不满。所以，真的没有必要一揽子否认对方，不如尝试着理解对方，先接受对方的想法，再把那些不合理的地方拿出来，给一些建议，这样不好么？ 03 站在同一阵线这次我来聊聊自己的故事。我也曾经对领导的指令不满，某一次领导要求我对我们双十一活动进行一次架构调整的时候，我有一肚子怨气。为什么？因为我又要加班了。 尤其是这个调整才刚刚做过不久的时候，一下子就会让内心的怨气爆发出来。 但是真的是领导不懂么？这也未必，只是于我自己而言，增加了我认为没有必要的工作量罢了。然而我自己的利益，于领导而言不重要，所以这个理由，永远没办法说服他。 这时候我们需要站到对方角度去讨论： 我也觉得这样架构调整会很有用处，但是实现起来改动可能不少，目前项目工期比较紧，上线时间也迫在眉睫，如果这么修改，我担心可能会影响到现有的功能。我个人建议，目前还是先保证现有的架构完成上线，把这个改造放到下个版本中，您觉得呢？ 不要强调这件事是重复的，不要强调我们做不完它，而是告诉他：如果这么做，我们的利益会有损害，我们可能会有背锅的风险。那是不是结果会不同呢？ 04 用你的方式尊重领导这是最后的一点，我们建议提了，我们也站在了统一战线上讨论利益了，但是领导就是不认可，那我该怎么办呢？ 很简单，尊重他，并用你的方式做到最合理。 当你们有了冲突，并且看上去不可调和，那么让领导做决定就好。用自私一点地角度说，这件事领导决定了，那么他就承担了最多的责任。并且你站在了与他同一阵线。 事实上，这不是自私，这是职场的规则。权利与责任对等，所以他承担了最多的责任，自然就可以有更大的决定权。 如果最终结果是好的，那么你站在了他的身边，你没有犯错。 如果最终结果是失败的，是错误的。这个结果他自己要承担，而你，更不要再去“提醒”：我曾经给出了什么什么样的建议。这真的没必要，这种事情不需要提醒，提醒只会显得你“幸灾乐祸”，而不是“高瞻远瞩”。 能在职场上跟领导一起背锅，帮他收拾个烂摊子，未尝不是一件好事。 所以最后，事实上，领导“什么都不懂，还爱瞎指挥”并不是问题，怎么和他有效的沟通和交流，才是最重要的问题。你有类似的故事和经验么？不妨一起分享一下。 本文来自 风落几番 / 蚂蚁金服测试专家","categories":[{"name":"articles","slug":"articles","permalink":"http://arthurwang.top/categories/articles/"}],"tags":[{"name":"articles","slug":"articles","permalink":"http://arthurwang.top/tags/articles/"},{"name":"EQ","slug":"EQ","permalink":"http://arthurwang.top/tags/EQ/"}]},{"title":"05 解读“上班第一天”的职场规则","slug":"eq-5","date":"2020-01-17T06:57:55.000Z","updated":"2020-02-02T16:33:18.000Z","comments":true,"path":"2020/01/17/eq-5/","link":"","permalink":"http://arthurwang.top/2020/01/17/eq-5/","excerpt":"","text":"世界上最快乐的事，莫过于为理想而奋斗。——苏格拉底 经过了面试的苦难，终于收到了offer。接下来就迎来了考验大家职场“情商”的第一课：上班第一天。 无论你在大学里有多厉害多风光，毕业了进入某家公司后，你依旧会从零开始；无论你在之前的公司工作了多久，有多少成绩，跳槽到了一家新的公司以后，你又将是一名新人。 这个“第一天”的论题其实可以拆分成两个方面，一方面呢是“我能做什么”，另外一方面则是“我会遇到什么”。我们暂且把第一个问题向后放一下，先聊聊上班第一天可能遇到的事儿。 我也就这个问题先跟一些学生、朋友聊了聊。看看大家对于进入公司第一天，有过哪些印象深刻的事？ 发现居然很多同学都对第一天上班时遇到的事情印象深刻，大家都纷纷道出了自己在上班第一天碰到的 N 种遭遇。我在这儿简单总结一下，如果你正准备进入一家新的公司工作，那要提防以下几种可能遭遇的事件了，以免让你在上班第一天应有的美好回忆“变味”。 ROUND1： 无故被冷落 “小灰”大学毕业面试到了某互联网公司，第一天上班，大家都很忙，自己的老板简单给他指定了一个座位和让另一个妹子带他以外，就去开会了。本来开始还好，后来他感觉有点不安，因为团队里氛围很好，大家大多数时候在忙着，但是偶尔闲暇呢也会聊聊天，互相分点水果零食来吃。但是当小灰想要搭腔的时候没有人搭理他，也从来没有人叫他一起吃零食什么的。 小灰很是忧伤，也不知道是别人怕生，还是刻意忽略他，加上又是第一次工作，所以也不知道怎么加入大家，一天都在尴尬和冷落中度过。 有很多小伙伴都是被这样的情绪困扰，以至于越来越不愿意融入大家。要知道程序猿的世界里，尤其是在一些互联网公司，大家整日忙于无休止的工作之中，很多闲暇时间都是为了放松一下情绪，那么自然，如果新人不主动，老人也不会过于主动去跟你搭讪。 身边曾经有两个鲜活的例子：我们暂且称两个主角叫小 A 与小 B。 小 A 比较内向，遇到这样若有若无的冷落，总觉得是别人看不上她，于是在后来的工作里更加畏首畏尾，生怕自己做错事情被别人嘲笑指责，也更加不敢发出自己的声音。领导、同事都不了解她擅长什么，最终试用期结束便离开了。 反之小 B 就相反，经过了第一天的尴尬，第二天，带了零食和水果，主动跟部门里的大家分享，热情与老人搭讪，午饭时间也趁机加入了一组老人的“午饭团”，很快融入了大家。 要知道，没有攻不破的老人，只有不努力的新人。不要觉得只有你自己需要适应新公司的环境，实际上老人也要适应你这样一个新人的存在。所以对于新人的你，很好的建议就是：积极、主动、热情，哪怕你是个内向的人，这时候也要首先释放出善意。当然，尽快选择加入一个“午饭”的队伍，对你融入团队也是有非常大的益处的。 ROUND2： 弹性工作制的杯具 “小灰”跳槽到了一家新公司，之前 HR 通知时候告诉小灰公司实行的是弹性工作制，名义上规定 9 点上班，实际上 10 点前到公司就可以了。于是小灰很乖巧地在 10 点左右到达，结果发现部门的同事已经都开始了忙碌和开会，老板呢也没有时间把他介绍给大家了。 实际上不管公司实行的是固定工作制还是弹性工作制，当新人不明状况时，上班不迟到都应该是一项基本准则。就算得知公司实行的是弹性工作制，新人上班第一天也不应该迟到，因为万一部门同事都是准点上班的，那新人的“迟到”就容易让那些准点上班的同事产生心理上的不快。 同时，也会影响你第一天融入团队的速度。 比如像我们工作中，尽管也是弹性，但是大多数还是会比较早来解决一些凌晨发生的问题或者报警，所以如果你是一个新人，那么最好还是比标准上班时间提早一会到，这样也便于你可以在老人们“立足未稳”的时候在正式开始一天的忙碌前与他们拉近关系。 ROUND3： 到底什么时候才能下班？ 小灰是刚跳槽到现在这家公司工作的。上班第一天，他发现公司里有一个很奇怪的现象，虽然公司规定是下午 5 点 30 分下班，可是部门同事没一个准时下班的。特别是部门老大，到了下班时间居然还召集开会。 于是小灰倍感压力，不敢成为第一个下班的，就一直等啊等，直到有其他同事下班了才敢走。 但是很快小灰发现老大是个工作狂，非常喜欢加班，可能会在下班后“无限”延长他的工作时间。即使那时大家都已经完成当天的工作，但是老大不走，部门的同事也不敢下班，示图在老大面前有良好表现，毕竟谁都不想留下一个“不够努力”的名声。 小灰很苦恼，自己明明没有工作可以做了，却还是要陪着大家一起装模做样的加班。虽然也想过下班就走，但是很快发现有其他不太加班的同事绩效比较悲催，就把这个念头打消了。 网上曾经针对“看见同事加班，职场人是否会准时下班”的问题发起过一项调查，结果显示参与调查的网友中有大部分的人表示同事加班会让自己很有压力，受环境影响不得不“随波逐流”。可见同事加班，惹得自己都不敢轻易下班的现象在职场上并不少见，特别对不明真相的新人而言，更不敢在上班第一天就“轻举妄动”。 可能如果出于“正直”，我应该要写类似这样的话： 只要保证工作质量，其余的“假勤奋”都是不值得被提倡的。 然而我开头就说过，这次专栏更想写一些实话。所以实话说，如果你有一个很喜欢加班的领导，甚至有一个自己虽然不加班但是很喜欢“你们”加班的领导，那么适量加班是很需要的。更何况 996 现在几乎是互联网的标配，所以大家在入行前就要做好这个准备。千万不要做有性格的耿直 Boy 或者耿直 Girl，除非你已经是那个团队中不可获取的核心角色，不然大概率你会死的很惨。 当然，这里的加班未必都是无意义的。一般情况下你可以在这段时间去磨练下自己的技术，或者编写一些小工具，甚至是给自己的架构做一次升级调整。总之，还是新人的你完全可以利用这段时间让自己更出色一点。 列了几个非常有代表性的“上班第一天”的场景，目的还是为了让大家能够更快、更好地融入新工作、新生活。可以简单总结上班第一天相关的几个关键的点： 准备简短有效的自我介绍 提早 15 到 30 分钟到办公室 微笑 主动与老人打招呼 至少和一名同事交朋友 别拒绝同事的午餐邀约，如果没有人邀请，主动加入其他人的“午饭团” 保证你的老大随时可以找到你 少说前公司或者学校的事情，更忌讳抱怨 注意观察人与人之间的关系，总结办公室的游戏规则 前边看上去还好，最后一点是最难的。新时代程序猿必备的生存之道中，就包含“观察力”的情商。你需要用最快的速度找出同事之间的微妙关系，比如小 A 与小 B 关系很好、小 C 与小 D 从不交流、小 E 和小 F 面和心不和、小 G 跟领导似乎很亲近等等，这有助于避免你后续不小心踩到“雷”，同时也尽量避免在不明的情况下过早进入“雷区”。 另外，就是找到领导对你的定位和期望值。上班第一天不要过多展示自己，毕竟“都是腰间盘，为啥你要这么突出”。无论你自己的能力有多强，第一天还是要懂得“藏拙”一点点。 再有，就是找出办公室里让人不舒服的不成文规定。大到穿着是否有约定、领导是否喜欢加班、大家对于其他部门的态度，小到是否可以在工位吃饭、工作中的交流方式等等，都是需要你在入职的早期尽快通过观察总结出来的。 所以，在入职第一天甚至放大到入职的开始阶段，观察和总结也是非常重要的。 或许上面的总结或多或少有一些教条，我们的职业生涯上可能有很多这样的“教条”，也许很多人都知道，但是并不能做得很好。就像每个人都知道要努力要勤奋，但少有人能真正坚持一直奋斗下去一样。职业生涯中的这些“教条”，也需要我们在工作中的摸索、体会和感悟。 最后呢，说说我自己。在我看来，在职场中的新人，最大的难度就是各种“势利”的环境。不像前边情景中那样干脆无心，而是真正来自于老人的“不屑”、“欺生”。我曾经有过这样一段不太美好的经历：由于当时是一个半空降的领导，所以确实受到了很多其他兄弟部门的“欺负”。这段偏对抗的经历说来话长，但是确实让我受益颇多。 其实势利这件事，不仅在公司里存在，只要有人的地方就永远避免不了。古语有云：穷在闹市无人问，富在深山有远亲。 扪心自问，我们自己是不是也会有势利的时候。马路上我们可能会躲着点浑身是泥的建筑工人；看到开车的女司机会不由自主的谦让；手头上工作很多的时候，哪个部门的人比较难说话就优先完成他的事情，等等等等，不要说你没有过。其实这也是势利。小时候有的家长告诉你多和成绩好的孩子玩，离成绩不好的同学远一点，所以，从小开始，我们就有一颗“势利”的种子。 势利确实让人讨厌，但是每个人又免不了势利的时候。 势利并非完全坏事，有些阅历的人，很容易通过穿着打扮、人的神态等外部特征，来确定对方大致是什么样的人。 我跟很多同学聊过，发现大多数刚进公司的新人，会感觉碰到更多的势利眼。我总结了一下，大概有两方面的原因： 第一，新人的敏感。刚进公司，对一切都还不了解，自己又还什么都不会，就会更加在意老员工的目光。有时候，老员工不经意的一句话或一个眼神，也许会让你想半天：是不是 XX 对我有意见了。至于有些素质本来就不高的老员工的“欺生”，更会让新人郁闷不已。 第二，确实可能会碰到势利的人。如果是有背景的新人，比如你是大厂出身，可能这样的人会收敛一点，对那些没啥背景也什么也不会的菜鸟，自然可能从内心里瞧不起了。 碰到这样的情况，你所能做的是：把自己的心磨砺得坚韧一点，放下不必要的防备，真诚地和老人交往。不要一遇到问题，就把事情往最坏的地方想。也许今天让你觉得很郁闷的事情，到明天来看完全是自己的误解和多虑。坚强一点，把这些对你不好的人和事当作一种常态，看淡一些就好。 如果你真遇到了那些让你感到很势利，并让你很不爽的针对你的人，那也不要紧。因为不由分说地让一个“新人”感觉到自己势利的人，在公司里往往也是些不太如意的人。稍微混得好一点的，或者有比较好的修养，或者比较善于隐藏自己。所以，只要这个人不是你的 Boss，大可以不用把他当回事。 即使有一天你成为老人了，遇到新来员工，也不要有“终于等到这一天”的想法，应该多给新人指点和帮助。在陌生的环境里，第一个对自己友善的人，人们通常会把这个人当作自己的朋友，所以给新人的帮助，也许会给你带来新的朋友。 善待新人，从逻辑学的角度，其实也是善待了你自己。 本文来自 风落几番 / 蚂蚁金服测试专家","categories":[{"name":"articles","slug":"articles","permalink":"http://arthurwang.top/categories/articles/"}],"tags":[{"name":"articles","slug":"articles","permalink":"http://arthurwang.top/tags/articles/"},{"name":"EQ","slug":"EQ","permalink":"http://arthurwang.top/tags/EQ/"}]},{"title":"04 与“难缠面试官”不得不说的故事","slug":"eq-4","date":"2020-01-17T05:59:55.000Z","updated":"2020-02-02T16:33:08.000Z","comments":true,"path":"2020/01/17/eq-4/","link":"","permalink":"http://arthurwang.top/2020/01/17/eq-4/","excerpt":"","text":"每个人都是自己命运的主宰。——斯蒂尔斯 上一趴我们主要聊的是“从自身做起”，完善自己的面试情商，争取在面试过程中不犯错，但是呢，不排除我们在面试过程中，遇到各式各样奇葩的面试官。比如，在我来蚂蚁之前，曾经去某二线互联网车企面试： 当时的我啊，也是“年轻气盛”，直接回复他：那您真厉害，我就等着拜读您大作了，到时候别忘了打电话通知我一声。然后扭头离开了。 后来随着自己开始不断地面试别人，加上参加了更多的面试，也结识了身边更多的面试官，发现每个面试官都会有自己不同的性格，甚至于同一个面试官，在不同的时间和心情下也会表现出不同的面试风格。 所以，接下来的时间，我们一起聊聊那些“奇葩的面试官”。 “谦虚和善”到不像面试官的面试官这里要高能预警下！这类面试官看上去非常友善，用轻松的语调寒暄、用夸赞的语气回复，所以很多人在面对这类面试官的时候会心情愉快，自信暴涨。 这都是假象！ 这都是假象！ 这都是假象！ 重要的事情说三遍。为什么说的这么肯定呢？因为我自己大多数时间也属于这种。虽然看上去非常容易打交道，但是实际上却还是很有城府，内心非常严谨，拥有还比较强的洞察力。但是，这种面试官会非常喜欢赞扬、同意的对话方式，让你感觉自己面试的表现非常成功，然而实际上稍有不慎，就会被默默淘汰。 应对策略： 如果某天你遇到了这种“笑面虎”式的面试官，千万不要放松警惕，要保持高度警觉，比平日还要老实地谈自己的工作、技术和想法。这种面试官并不喜欢你放低身价，一味迎合；更加不喜欢骄傲自满，夸你两句就觉得自己非常了不起。 这样的人表面谦虚，内心又有着自己的骄傲，所以展现自己真实的水平就好，遇到不会的大可以虚心请求指教，不然就算你胡说乱说，他也会笑眯眯地说：不错！然后把你的名字从通过的名单上划掉。 “武林盟主”式面试官不知道大家有没有遇到过这样的面试官，就像我开篇提到的那样，给人一副“普天之下，唯我独尊”的样子。在他的心里无论你的能力、技术、出身多强，但是永远不会在任何一方面强于他自己。所以，他的语气是傲慢的，不会带任何笑容，甚至恶语相向，亦或是在你说话过程中不时的粗暴打断你。 我听到过很多这样的抱怨，我的不少学生都跟我说：我去XX公司面试有一个“黑面煞”面试官，从来没有见过这么讨厌的人。 这种人让你感觉很难对付，加上自身确实有一定实力，所以很容易一下子打击掉你的自信心，同时伤害你“脆弱“的自尊。 应对策略： 后来我发现，这样的面试官未必是真的性格如此。我身边就有这样善于“伪装”成盟主的面试官，随着面试的次数多了，我自己有时候在心情不好或者烦躁的时候，也会变身如此。而我认识的大部分会在面试过程中有如此表现的“奇葩面试官”反而在生活中比较好说话，而且他们的面试通过率，居然要高于平均数。大多数时候这都是一种面试方式，类似于压力面试。毕竟，未来你的老板未必比这个面试官更好说话。 值得一说的是开篇的故事还有后续：在我生气地拂袖而去之后，居然意外还收到了该公司 HR 的下一轮 HR 面的电话。当时在诧异之余还是选择了放弃，不然说不定还能与那个面试官再去见面聊聊。 所以呢，遇上这种面试官，不要太过于在意态度的恶劣。如果大家心理上过不去的话，那么大可以做一些心理建设，比如：他是不是刚刚被领导骂了？他一定是遇到烦心的事儿了。这样或许就会平静很多。 同时，不要刻意追求讨好。这种吧，跟我们追女孩是一样的，能够追到女神的一定不是那个嘴最甜的，要不你就长得帅，要不你就有才华，都沾不上边呢，要是特有钱，也还是有希望的。 这说明啥？说明追求这事儿最重要的是展示自己的亮点和能力。所以，平静一点，用简洁有力的回答来对应哪怕是尖酸刺耳的问题，也不必在意他有什么反应。即便他说了什么不好听的话，如果你觉得这份工作对你还有吸引力，那么大可以不动声色，不用像我一样觉得收了委屈离开，更不用对着硬干，只把他当做外强中干的“纸老虎”，从战略上藐视他。 “卖弄”式面试官这些人是天生的演说家，他们非常喜欢说话，只要你一个不小心触及了他熟悉的话题，便开始口若悬河、滔滔不绝。从理论倒实践，从你的简历聊到他的工作，健谈到让人叹为观止，表现欲望极其强烈。给人的感觉，他的目标似乎不是来面试你的，而是为了表现自己。 应对策略： 无论你是不是一个擅长表达的人，都请收起你的话语权。让这样的面试官无拘无束地表达他自己想说的任何内容，大多数时间静静地当一个好的聆听者，必要的时候插几句话表示你对于他的演说非常有兴趣而且非常佩服，表情上大可以做出一副乖巧、认同的样子，让他持续聊下去。 不知道大家有没有听过相声哈，就像相声一样，既然面试官不让你做那个逗哏的，那就好好把捧哏的角色做好。ps：担心大家理解不了上边的相声术语，我们换个方式，如果面试官觉得自己才是“郭德纲”，那你就好好做“于谦”。这样，多半就会通过。 切记不要焦虑不安，也不要感到厌烦。不要担心时间过长，除非有天大的急事，只要还能忍，就可以继续忍下去。焦虑不安会让这种面试官非常扫兴，那么结果，你懂得。 “东拉西扯”的面试官实话说，我自己是没有见过这类面试官的，但是听很多学生说过。他们的特点呢，就是面试过程中不太像技术人员，反倒有点像公务员，做起事情来不紧不慢，效率很低，对别人的回答、甚至是简历都不太放心。不管你写的多详细，他们还是会从简历里的东西问起。最可怕的是他们的面试完全没有层次和逻辑，东拉西扯，想起来什么说什么。 应对策略： 这样的面试官有两种可能，一种是刚开始担任面试官角色，自己本身没有关于面试的体系，所以聊起来比较杂；另外一种就是刻意用繁杂的提问方式打断你的惯性思路，希望看到你下意识非连续性思考之后的反应。 无论是那种情况，作为面试者，一旦遇到这样的情况，一定要按捺住性子，说话保持温和谦逊的口气。回答问题一定记得要尽量周全详细，甚至可以啰嗦，如果讲到后边发现前边有忘记的情况，也想办法弥补。多做说明，少做辩解，而一旦面试官开始讲话，那么就可以专注聆听，并且不要插话。 我自己不是这样的面试官，但是换位思考呢，我觉得我会尽量多用“你觉得我哪里没有讲清楚？还需要我补充什么么？”之类的话术和语气，表达方式上也尽量去配合他的说话方式。 所以对付这样的面试官，大多时候最重要的就是耐心，相比其他面试官还是很容易被打动的。 “死板”的面试官尤其我们做技术的，很容易碰到的另一类面试官，就是非常死板、按部就班。你进入会议室或者面试场之前他就已经坐好了，而你的出现似乎对他也没有任何影响，仍然自顾自的想着什么。 我自己印象相对深刻的一次吧，就是我刚毕业时候去面试了，遇到了这样一个面试官。我很客气地去跟他打招呼、寒暄，但是他始终一副“爱答不理”的样子。面试过程也是死气沉沉，对我的回答也置若罔闻，看起来就像他自己都没听进去一样。甚至让我都开始怀疑自己，直到下一轮面试的通知电话响起。 应对策略： 工作了很久我突然发现，这样的面试官倒还不在少数，他们往往技术很好，但人相对内向，比较固执，也会坚持原则。他的考察方式大多时候不会考虑你的性格、你的处事之道，对于他来说，技术就是一切，所以只要你的实力足够，按部就班的发挥就 ok 了。 当话题谈及自己的能力、要求、感受时一定要慎重，少说为妙，最好说具体点，宏观而浪漫的设想一般不说为妙。不要一味的画大饼、吹嘘自己，因为这样的面试官大多也仍然在一线工作，而且也知道你过去公司的大体水平，实事求是反而能留下更好的印象。 “麻木”的面试官在我收到过的反馈中，我觉得这样的面试官是最可怕的。依然记得前不久有个学生跟我聊起： 上周去XX公司面试，那个面试官看起来非常淡定，面试过程非常漫不经心。我在回答他问题的时候，感觉他特别特别心不在焉。有时候我明明在认真回答问题，他呢一边听我说话一边在简历上画圈。对了对了，我做自我介绍的时候，他一直不看我，看窗户外边，引得我都忍不住回头看看，是不是外边有只哥斯拉…… 为什么会这样呢？我很是认真的自我检讨了一下，发现可能在别人眼里，我或多或少也有这种“症状”。大约是因为面试的次数比较多了，你来面试，第一次看见我总会有几分新鲜，而面试官自己呢，因为见多了，就司空见惯了。甚至有时候，我通过简历和其他渠道的了解，已经大体知道了你的能力，只需要在面试过程中再落实一些模糊印象就够了。 甚至更多时候，我在进入面试的几分钟内已经确定了你的结果，只是表面上昂不好直接拒绝，所以坚持着半小时甚至更久的面试流程。 应对策略： 实话说，我没有非常好的应对策略。因为往往最麻木的也是最有主见的，除非他能够在面试中发现你的闪光点，不然大概率上很难更改他的第一判断，而一旦你感受到他的心不在焉，那结果自然。。。 所以，这里的建议就是：说一些你简历里覆盖不到的闪光点，找他感兴趣一点的点深聊，刺激一下他的新鲜感，加深这次的面试印象，这样，方有一线生机。 今天这一趴，我们从面试官角度分析了一下你该拥有怎么样的情商，什么样的分析能力和应变能力来面对不同的面试官。总结下来关于面试的两个小节，整体上讲其实也就是一句话：带着情商去面试！ 最后，还是祝愿大家，能够在求职路上顺风顺水，做专业的“面霸120”。 本文来自 风落几番 / 蚂蚁金服测试专家","categories":[{"name":"articles","slug":"articles","permalink":"http://arthurwang.top/categories/articles/"}],"tags":[{"name":"articles","slug":"articles","permalink":"http://arthurwang.top/tags/articles/"},{"name":"EQ","slug":"EQ","permalink":"http://arthurwang.top/tags/EQ/"}]},{"title":"03 做高情商的“面试者”","slug":"eq-3","date":"2020-01-17T04:57:55.000Z","updated":"2020-02-02T16:32:58.000Z","comments":true,"path":"2020/01/17/eq-3/","link":"","permalink":"http://arthurwang.top/2020/01/17/eq-3/","excerpt":"","text":"衡量一个人的真正品格，是看他在知道没人看见的时候干些什么。——孟德斯鸠 在这一个篇章中，我想跟你聊聊面试。话说我自己在软件行业摸爬滚打了十余年，招聘面试也是我自己的日常工作之一。想来被我面过的人也估计不下千人（还请不要拿我的头像照片当飞镖靶子），而作为被面试者参加的面试也有几十场，可以算是有比较丰富经验面试经验的“老人”了。 面试到底是什么？说直白一点，面试就是把自己变成商品，不遗余力地推销给面试官，从而打动他的过程。 很多同学都觉得面试过程最重要的是自己的技术水平和能力测试。这是当然，技术能力一定是最重要的。但是不可忽略的是，面试官也一定会更加注意考察你的“情商”。 所以今天我们聊几个小场景来说说面试者应该拥有怎样的情商。 简历过于夸张我是面试官的同时，也是个讲师对吧，如果你看过我的课程也会知道：我也有给大家讲如何去美化自己的简历。但是注意哈，美化不是让大家夸张，我在面试过程中碰到过很多同学，为了赢得面试机会和面试官的好感，不顾实际情况，写一些根本没有的经历，或过分夸大相应的经验和成绩。 我们不讲大道理，什么“造假太虚伪‘，或者说”诚实是美德“这样比较空的话。只想说：真的不要把面试官当傻子。 记忆很深刻的一次，有一次我面试一个测试架构的岗位。小伙儿人很帅，年龄不大，但是简历中来自一个中型互联网公司，最厉害的部分就是在一年中带队搭建了包括性能测试平台、WEB自动化平台、TestOPS流程、“ALL IN ONE” DOCKER等巨型项目。单看简历着实是人才中的人才。 但是面试过程中，发现无论是对自动化的理解、对DevOps的认识、甚至是对性能测试还需要监控调优这些都不甚了解，实在是让人匪夷所思。 这是吹“爆”了的个例，之所以讲出这个故事，只是因为这个小伙儿的夸张让我印象十分深刻。除了这种项目上的造假，还有工作经历、学历上的造假。实际上你要知道，绝大多数的面试官都是技术OK、沟通能力不错，你仔细想一下，这样的人一定是有比较良好的人脉关系，所以除非你来自某个实在难以挖掘的公司，不然你真实的工作情况和背景大多数还是很容易被挖出来的。 就算偶然被你蒙进去到了工作岗位，面对远超自己能力范围的工作又当如何？ 当然，实际一点地说，之所以这么多人会篡改简历，给自己的简历添加莫须有的工作经历、工作职责、工作职称，很多时候也是无奈之举。因为现在的公司开始越来越多地去强调学历、经验，而让很多本身有能力的人被这些基础门槛挡在门外，或者给的条件是最差的。 真实的情况确实是很多简历造假的或者在面试过程中善于说谎的，获得了一份工作甚至是很好的offer，因为我想做一个真实的专栏故事，所以我一点都不避讳这一点。我们谁都不可能 100% 真实地面对面试官，毕竟这是对你的一次考试，我们都希望展现自己最好的一面。 所以在这一小节我想表达是：简历不是不可以美化，但是教育经历、工作经历尽量不要篡改，而项目经历，可以适当美化，但还请一定符合自己的能力，不要无休止的夸张。毕竟牛飞上了天，就很难拉下来了。 不得不说，适当的美化简历，确实可以让我们快速；得到面试的机会。我并不排斥美化，不过，请记住几点： 不要把面试官、HR当傻子 技术上能力上请自觉找齐，做自己能力范围里的事儿 就像照片一样，可以P图，但是记得别把地板都给P歪了，更不要做换头术，毕竟你又不是要做个“网红”。 过度自信、骄傲重复前边的“知识点”：面试其实是推销自己的过程。有些人自视甚高，在面试中表现出一份天之娇子、唯我独尊的架势，不愿意从基础工作做起，觉得自己是要做大事的，要去“改变世界”的。 任何一件商品的推销，都不会用“只有亿万富豪才配拥有我”这样的slogan。面试官可以认为你很强，技术很厉害，但是记住：任何标签都不是自己打的。经常遇到一些目空一切的面试者，暂且不说你是否具体匹配你骄傲的能力，只是想一想，面试你的人大多以后会是你的同事、你的上司，换位思考一下，如果你是面试官，即将面试的同事是一个给人第一印象贴满骄傲、跋扈标签的人，你是否会选择跟他做同事呢？结果显而易见。 就算你的能力确实很优秀，也请你放下你的骄傲。这里说放下，是希望你态度上不要那样高高在上，也并没有要你放下自尊、卑躬屈膝。无论你有多强，你的履历多光辉，你的历史多辉煌，每一次面试都是个从零开始的过程。 记得：面试对你而言，是一场推销。面试官有更多的选择，不会非你不可，哪怕你是最优秀的。 “挤牙膏式”面试上一段我们聊到面试是一场推销，哪怕你是一个再不喜欢说话的人，既然要推销自己，就一定不能“沉默是金”。我不止一次，这毫不夸张，真的不止一次遇到类似下边的对话： 尽管大家的时间确实都非常宝贵，但是我真的不介意你在面试的时候多说几句。只做不说是好的，可是面试时候，这样不能把你的技术、能力、经验、优势向面试官说明，而面试官呢，更加不知道你是因为紧张，还是没准备好，又或者你的性格如此。至少，面试官会觉得，你的沟通能力和心理素质不强。 “我很抢手”我不代表别人，但是这是我和我不少面试官朋友们很不喜欢的一种类型。他们会或故意或装作不经意间透露给你： “我已经有4个offer了” 或者告诉你已经在哪里进了三面了，等等。总之就是表达我很抢手这样的节奏。不乏确实很优秀的面试者，但是有一些人并不是真的有其他offer，而是在耍小聪明，编造故事，企图让面试官觉得他确实很优秀。 一般情况下，我的处理方式是：看破不说破，但是心里对你say no。 可能有猎头、有一些面经或者是培训讲师告诉你这么做，但是很容易被经验丰富的面试官识破，得不偿失。 最极端的情况，曾经有一个同学我已经准备通过了，由于表达了自己“抢手”的意愿，我只能做个“好人”：避免你出现选择困难，所以我就直接拒绝你吧。 负面情绪爆棚对于”为什么离职”这个问题，我在面试过程中遇到过不少人会把这个原因归纳为别人。比如公司太小，制度太乱，产品不行，领导傻逼，同事太烂，加班太多等等等等。 永远不要在面试时抱怨前东家。抱怨会让面试官对你产生负面印象。 导致离职的理由其实可能会有很多，决定离职的原因也很复杂，根本不可能是一两句话能够解释清楚的。怎么回答呢？首先要强调你在工作上是尽责的，你的离开也不是自己所希望的。具体的原因大体就归纳为：发展前景、工作深度、更好的学习，最差了也要用公司距离这样的烂理由。这样的理由往往能得到面试官的理解和认可，而不会贴上任何负面标签。 就算你确实在前面的工作中遇到了很多的不公、碰到了百年一遇的“SB”领导，但是面试不是让你讲故事的地方，你也很难在几分钟内讲清楚到底发生了什么。所以，还是正能量一点吧。等你入职了，咱们可以出去喝酒探讨，“我有酒你有故事”，不好么？ “面试带跟班”我觉得可能有很多刚毕业的同学会有这种情况，拉着自己的男朋友/女朋友来面试（因为我们的小灰同学没有女朋友，所以他也很伤心，不同意再出场了）。不管怎样，陪伴面试还是不太合适的，如果真的如胶似漆，那么在公司附近随便转转，不要在公司大堂等候。 说了几种带有特征性的“情商低”的面试表现，我们也来顺便总结一下除去技术以外的面试准备，毕竟面试前期准备越充分，面试成功率越高。 对公司的了解：包括公司的主营业务、在市场上的地位、企业评价； 对面试职位的认知：你要面试的岗位职责是什么，需要什么样的能力，如果有熟识的朋友，可以更深入了解下工作的大体内容； 对自己的评估：好好想想你胜任这份岗位的优势在哪里； 个人状态：充足的睡眠、合适的服装、提前或至少准时到达； 记得带一份个人的打印版简历，以备不时之需。 再有就是面试过程的准备，比如你该如何进行一个能够吸引面试官的自我介绍，如果遇到不会或者不方便回答的问题该如何应对等等。 前边说面试是一次推销，其实也是一次学习的过程。很多时候我们最在意的是面试的结果，而一旦不尽如人意就抱怨下：唉，他们太没眼光了。实际上呢，小心准备、大胆发挥之后的就是谨慎总结了。每次面试，不管成功或者失败，都要总结分析自己的得失，让自己下次表现能够比今天好一点点。 聊完了面试者自身，下一趴我们换个角度，从面试官角度聊起。那么你有什么样的面试故事么？欢迎一起分享。 本文来自 风落几番 / 蚂蚁金服测试专家","categories":[{"name":"articles","slug":"articles","permalink":"http://arthurwang.top/categories/articles/"}],"tags":[{"name":"articles","slug":"articles","permalink":"http://arthurwang.top/tags/articles/"},{"name":"EQ","slug":"EQ","permalink":"http://arthurwang.top/tags/EQ/"}]},{"title":"02 不一样的情商课：程序员需要什么样的“情商”","slug":"eq-2","date":"2020-01-16T05:57:55.000Z","updated":"2020-02-02T16:32:47.000Z","comments":true,"path":"2020/01/16/eq-2/","link":"","permalink":"http://arthurwang.top/2020/01/16/eq-2/","excerpt":"","text":"02 不一样的情商课：程序员需要什么样的“情商” 构成我们学习最大障碍的是已知的东西，而不是未知的东西。—— 贝尔纳 写在前边的话每次提起程序员的“情商”，大家脑海里想到的故事都是这样的： 看到这样的故事和这样的调侃，我都有一点奇怪：我们程序员啊，或许情商不太高，但是也并不是智障好不好。至少像这样故事中“退化”到这种程度的程序员，我在工作这么多年以来，从来没有见过，这样的“情商故事”更多是杜撰出来的玩笑而已，而且仔细想想吧，这玩笑的杜撰者或许大概还必须自己得是个程序员。 所以，我们来聊一聊在我身边比较典型的“情商不足”的人。 浅谈情商先来说说我们生活中见过比较多的一种类型：过于自信，目空一切。 很肯定的是，程序员本来就是非常非常有自信的一种职业，我也不例外。我会对我自己写的每一行代码都爱不释手，鄙视一切其他人的代码甚至是自己过去的代码。其实这并不要紧，但是把这份自信无限制的放大到职场中，就适得其反了。职场有规则与价值观，放飞自我的任性，要出现在适合的地方。 我有一个前同事，技术能力非常出色，只是脾气非常火爆，经常称自己性子直，无论是领导还是同事，一言不合便“喷”了起来。开始还是以居高临下的姿态面对别人，最喜欢对别的程序员说教，不允许别人说自己不对，后来呢变成老板交代的工作，表面答应很好，之后推脱给别人去做，出了问题再各种借口。于是朋友寥寥，也有好心的同事提醒过他，但他总认为自己的资历深能力强，老板离不开他，不会把他怎么样。 事实是，无论你再有才华，持才傲物就是职场大忌了。越是在职场，越是要遵守职场的规则。地球离开谁都照样转，公司缺了谁都不会倒闭，时至今日，我还从来没有发现有什么“缺你不可”的事儿。 所以，如果你认为你非常重要，可以享受一些特权，那么对不起，你一定是想多了。 也有那么一种人，是那种自认为幽默感非常足，喜欢开玩笑却没分寸的人。 幽默这件事吧，我觉得我自己稍微有一点发言权。我是一个土生土长的天津人，所以从蹒跚学步开始就少不了受到相声的教育，大一点了呢，无论是茶馆还是澡堂，处处弥漫着马志明先生的教诲。上了大学加入过相声社，打过快板说过相声，乃至到现在有了十来年的讲师经历，想必幽默这件事我肯定比不了专家，但是在诸位面前应该还是有点话语权的。 幽默确实是个技术含量非常高的活儿，有的人会觉得自己很好笑，各种“妙语连珠”，其实往往是流于恶俗，没有分寸。还是讲个例子吧。 我曾经有过这样一个同事，说“曾经”，想必大家也猜到了现在的结果。这是个比较愿意去活跃团队气氛的人。某一次，我们部门与其他部门配合一个项目，我们部门有一个长相一般的小姑娘受到了对方项目经理的夸赞，这时候，我们的“幽默大师”出现了： “哇塞，你居然能够透过她的长相看到她的能力，真是厉害！” 不要觉得你是在“吐槽大会”上，职场不是如此吐槽的，黑色幽默拿来自黑是“幽默”，用来黑别人那就惹人反感了。所以，请不要滥用自己的“幽默”，给幽默增加一点深度，过犹不及。 还有一种，也是最多的一种吧，就是喜欢抱怨，光说不练。当然，抱怨本身没有问题，这是一种人生态度和性格，我们不能强加更改，更核心的在于“只抱怨”。 我刚工作的时候，有一个同事，现在关系也还不错，平时呢，我们偶尔出来聚个小餐、喝口小酒，顺便“工作的烦恼和哥们说说，上司的事情跟朋友谈谈”。最常挂在嘴边的话是：我真是受够了！这都是哪来的XX领导（请原谅我用XX替换掉在电视里应该开始哔的音效，自行填空）！接下来就是各种抱怨。 我得承认，每个人都喜欢抱怨，我也一样。然而多年的职场磨砺告诉我，没有任何一份工作是完美的。轻松愉快的工资少，给钱多的得加班，加班少的要心眼，要是真有一份工作机会告诉你工资多、不加班、办公环境好，那估计八成这是要把你卖到东南亚。尴尬不？其实不管在江河湖海还是在池塘，不会游泳的你还是不会游泳。 抱怨归抱怨，如果你一直停留在“领导看我不顺眼”这种思维里边，你就永远是一个“受害者”。真正的情商高的人会：大声抱怨，大口吃肉，然后扶石探路，摸索着前进。 所以，同志们，不是告诉大家不要抱怨，而是不要停留在抱怨，积极面对困境，毕竟“人在江湖飘，谁能不挨刀”，但是，“既在江湖飘，哪能总挨刀”，只要人在江湖，难忍的问题还是会在不经意的瞬间神出鬼没，并不会以你的意志为转移。也更加不是换一份工作就可以躲避的，唯一能做的就是修炼。挨欺负要总结，被针对要思考，具体的呢，我们后边聊。 论“老实人”这个时候，估计又有同学要说了，风落啊，你说的这些例子都太极端了，而且都是他们个人原因，我可跟他们不一样，我是个老实人。 说到老实人这个词，在我年少无知的时候，这还是一个褒义词，至于现在，小灰下边的表情告诉你答案： “呵呵！！” 实际上职场上纯正的老实人怕是不多了，但是很多人会有“老实人”的特征，这在职场上也是吃不消的。我在写这篇专栏的时候，特意好好回顾了一下身边的老实人，大体上有这么几类： “讨好型”老实人很多人都有这种讨好型的人格，表现在职场里就是特别特别考虑别人的感受，既怕麻烦别人，更怕得罪别人。 比如，加班去吃饭，太累了忘记了叫小白一起去，回来就想：小白是不是会不高兴？也会在每次开会后考虑：我的发言、我说的话会不会不合适？ 甚至工作中难免的摩擦，也要考虑：我说的话是不是不太合适？ FINE，就算“职场如战场”，但是我们是为自己而战。职场上不需要忽略自己，更不需要舍己为人。 “好说话的”老实人太好说话、耳根子软的老实人在职场中比比皆是，无论别人说什么，他都觉得：可以，没问题。更有甚者，前一天刚被人坑的死去活来，第二天别人随便恭维几句，立刻化干戈为玉帛，手牵手共同展望美好明天了。 这样的老实人是真的那么“好说话”，真的“那么好脾气”么？也不然。我之前招到过一个应届毕业的实习生，大体就是这样的“老实人”，别人让做什么做什么。后来实习期满结束，我请他吃饭送别，也问到了这个问题。 他说：其实我每天回去都不开心，都要骂自己，可是我觉得我才刚毕业，什么都不会，我再不听别人的话，人家更加不会教我东西了。人家不都说么，吃亏是福，我觉得吃亏也是好事吧？ 虽然说来如此，但是别人就是会吃准了这套，不断提要求，不断削弱老实人的话语权，最后，你就什么都没有了。 所以我觉得，职场上的奥密在于：我们的目标可能不是想说就说，而是想说“不”就可以说“不”。当然，这很难，甚至我自己也不能做到（老板你还好吗o(￣︶￣)o），但至少在适当的时候给自己说“不”的权利，给自己说话的自由。 “不会说话”的老实人这是我在职场中生活中最不想遇到的人，不知道该说他们直言爽快还是老实无脑，总之是既好笑又无奈。 有那么一个同事，别人呢，刚刚买了一套学区房，有人主动问起就非常高兴地跟大家聊起来，这个可爱的同事呢，突然开始插嘴：啊，其实吧，那个学校好多人都知道，不怎么样，攀比很严重还特别乱。瞬间全场安静。 然而实际上，他既没有对象更没有孩子，当然，这样的“毒蛇”不知道啥时候才能有对象。 我不知道他在说这句话的时候是出于嫉妒，还是只是表达自己知道的情况，毕竟我可舍不得买下帝都的学区房。这是不会说话的极端情况，但是想审视自己的同学，以后说话前可以多想一下：你的这句话会让别人有什么样的感受？ 点名了寥寥几种老实人，实际上还有很多。比如好面子的老实人、不够积极主动的老实人，甚至是没有底线的老实人等等，老实人本身没问题，但是职场中这些所谓的“老实”反而成为了限制自身发展的“缺点”。 不一样的“情商课”其实这一趴我们应该叫“情商课之反躬自省篇”。大家可以把自己跟上边的情商故事对比一下，先大体上看看自己到底有哪些不足，相信总可以描绘出一些自己的剪影。但是随着互联网时代的发展，软件行业的故事也在不断增多，面对不同的场景到底应该做什么、怎么做其实仍然是个大问题。 如果有熟悉我的朋友呢，可能知道，我是一个非常喜欢辩论的人，大学期间参加辩论赛后来又做领队的。喜欢到什么程度呢？这么说吧，我老婆一直不遗余力地想找渠道给我报名《奇葩说》！好吧，让大家失望的是，这么一大段夸奖自己的话并不是为了引入什么“将辩论带入职场”的思想，而是想起了《奇葩说》里黄执中说过的一段话： 人生的困扰，说到底，十之八九，问题都出在人际关系。而人际关系的困扰，说到底，十之八九，都是因为沟通出了问题。 无论家庭、校园还是职场，无论亲情、爱情还是友情……生命中，我们绝大多数的纠结与困惑，愤怒与失落，根源，都来自我们怎么与别人对话、协商、争论、说服。 所以，在我看来，真正的情商问题，是人际关系问题、是沟通问题。具体来说，是自我管理、与人沟通方式方法和心理态度方面的问题。 在这个专栏里，我并不想讲一些大道理，更不想用一些名人轶事来告诉大家：有情商应该怎么做事，我们应该学习黄渤、学习蔡康永的说话之道。混迹职场，失之一语，差之千里。我更愿意用一些“真实的”、“常见的”场景来细致剖析一下职场的情商。 曾经看过这么一句话，深以为然： 职场上，一个人的智商决定了他是否能够走上成功的道路，而一个人的情商却决定他能在这条路上走多远。 然而，没有谁是天生的情商高手，所以我们需要也应该付出时间去实践、提升，为自己开辟一条更宽阔的职场空间。 与君共勉。 本文来自 风落几番 / 蚂蚁金服测试专家","categories":[{"name":"articles","slug":"articles","permalink":"http://arthurwang.top/categories/articles/"}],"tags":[{"name":"articles","slug":"articles","permalink":"http://arthurwang.top/tags/articles/"},{"name":"EQ","slug":"EQ","permalink":"http://arthurwang.top/tags/EQ/"}]},{"title":"01 开篇词 | 我们面临的困境，往往不是“程序问题”","slug":"eq-1","date":"2020-01-16T04:57:55.000Z","updated":"2020-02-04T06:43:10.000Z","comments":true,"path":"2020/01/16/eq-1/","link":"","permalink":"http://arthurwang.top/2020/01/16/eq-1/","excerpt":"","text":"#01 开篇词 | 我们面临的困境，往往不是“程序问题” 天才就是长期劳动的结果。 ——牛顿 大家好，我是风落，目前在蚂蚁金服工作。 今天这个话题我其实想聊很久了。 如果要对我过去的工作内容进行一个总结的话，那么我大概会这样归纳：我是一个撸过代码、做过测试、运维过服务器、当过项目经理的 “全占工程师”。 如果让我对过去的职业发展说点什么，我应该会说：经历过外包、国企、外企的风风雨雨，现在终于进入了互联网的大风大浪。 如果还要给自己多加一点戏的话，那么我应该还是一个有着多年经验的讲师，兼职负责学员们的 “心理顾问”，听大家倾诉工作、生活里各种不为人知的故事。按照 “久病成医” 的指导思想，我大概可以算作三分之一个 “职场心理治疗师”，差的那三分之二，我觉得主要是因为我不收费。 当然，不收费就有不收费的好处，很多同学都愿意跟我聊聊心理话，我呢也不太会把大家当作学生或者客户，大多数时候该怼就怼，当骂则骂。或许大概因此吓跑了不少人，不过留下了更多的朋友，也获得了很多不太属于我的经历和故事。 前段时间，我耐下性子把最近两三年的问题整理了一下。除了那些技术方向的问题，被问到最多的问题是这类：风落，我该怎么学习和努力才能进 BAT、拿高薪？与之对应的，排在第二的，则是：风落，我刚进来 XXX 公司，可是感觉特别困难，不知道自己该怎么办？ 虽然我没有点石成金的能力，但是相比起来我觉得第一个问题比第二个问题容易回答得多。想要得到一份好工作、获得一份优渥的薪水，我们完全可以从专业技能、面试技巧、简历优化等方面去扩展开来，可是，身在职场中的问题，却没有那么简单。 职场上的困境，大多数时候不是由于你的技能水平、你的代码质量，而是在于无法简单处理身边复杂繁琐的小事、忙碌而又头痛的人际关系。 《教父》里有句台词：花半秒钟就能看透事物本质的人，和花一辈子都看不清事物本质的人，注定是截然不同的命运。这是影响了很多人的一句话，职场的本质在哪里，我说不清楚，但是看清本质的 “快捷方式”，几乎一定是情商。 之所以下定决心把这个话题跟大家分享出来，是因为前不久发生的一件事。 我的一名学生从某一线互联网 A 公司离职了。 他是个典型的技术男，在我的学生中算是比较优秀的那一批。先前是在一家小型公司做测试负责人，技术佳能力强，人长得蛮帅，也常被老板夸赞。 他不止一次跟我聊过他后续的学习计划、他的职业规划，A 公司就是他职业规划的一部分。技术、实力、机遇几乎都眷顾了他，如愿以偿地进入了 A 公司。然而，半年后的现在，却选择了离职回到一个不知名的小公司。 我很诧异，询问他原因。 他很久没有回复我，大约过了有一小时，告诉我： 自从进入 A 公司，他突然之间不知道该怎么融入这个环境。从之前的七八人的测试部门到现在的几十上百人的团队，从曾经的技术骨干到默默无名的小角色，好像突然就不知道怎么办了一样。很不容易交到了几个朋友，某一天的分享会议上，某 “朋友” 突然就把一个他刚刚完成与其炫耀过的小工具拿到会上展示给大家，并且说明是在 “朋友” 的指导帮助下，两个人一同完成的。然而会后却又可以若无其事的跟他打招呼。领导呢，似乎也不太信任他，总是明里暗里挑他的问题。最近，吃饭时还听到同事跟领导偷偷打他的小报告，于是季度绩效获得了一个非常烂的考评成绩。 他觉得自己的能力没有得到认可，技术更是没有发挥的余地，半年之内除了不停地加班和时不时地被算计，完全没有什么提升。 我突然发现这好像成为了一种普遍现象，在各大公司中或多或少的存在着。“与人为善” 的行为准则似乎已经不再适用于当今的职场了，但是我们真的不为善就要为恶么？ 放心放心，这里我不是要教大家主动出击，化悲愤为力量，以暴制暴。尽管职场上永远有那么一小撮 “善于弄权的黑莲花”，但是所有人包括我，都不希望有一天自己变成自己最讨厌的那种人。 于是，我决定推出这样一个专栏。在这个专栏里，我们不讨论技术知识，不讨论流程管理，而是讨论在职场中的生存之道、为人之道；探讨我们在职场的方方面面可能遇到的困境，以及尝试突破困境的手段；探讨一些不属于传统意义 “情商” 所定义的 “职场情商”。 蔡康永有一门 “情商课‘广为流传，有朋友从台湾游玩回来还特意带了一本竖版的《情商课》给我。所以，我把这个专栏起名也叫做《程序员情商课》。我希望大家在扎实的技术知识之余，能够多一份对于非技术的认识，更快地适应职场，也能够更好地应对职场中的困境。在这个专栏中我会介绍的内容可能会包括： 面试情商 作为一个老资格的 IT 人，面试别人和被面试是不可或缺的话题。在这部分里，我希望能够竖起一面放大镜，带你看清楚面试官的真实内心，也让你避免走上 “低情商” 面试的不归路。 职场情商 情商并不是曲意逢迎，溜须拍马，情商，是你懂得自己的想法，也懂得别人的想法，并且经过思考以后，可以把两者关系处理得更好。 职场中，我们会面临很多选择的十字路口，更会面临让人不知所措的困境，我希望这个专栏能够帮助大部分同学面临职场上的无奈和困难时候，能够更合理、更理智也更聪明的度过。当然，提高情商的过程，不可能一下子蹭蹭上升到一个高度，需要在日常生活不断积累、演练，所以，我们会选择几个在互联网职场中最常遇到的 “天堑”，一起去聊聊无奈的 996、悲催的背锅侠、心酸的 “站队” 史等等。 职场管理 此管理非彼管理，我希望在这一部分跟大家分享的是关于 “向上、向下、横向” 管理的心态，自我情绪管理的秘密以及人设管理的重要。有的同学在看到第一个词的时候已经疯狂了：啥，还能向上管理？当然。甚至说，在职场中，向上管理比起横向管理和向下管理更为重要，毕竟，你的老板才是决定你生杀大权的关键人物。 场外情商 除了职场内，我也想聊聊关于学习、关于行为举止的一些话题，所以也会穿插了一些其他的内容，比如一些热点事件，能够让大家看到不一样的职场，不一样的你自己。 啰嗦了很多，其实大家也知道，不可能有这样一本《职场 “杀敌” 秘籍之葵花籽宝典》一样的内容，能够帮助你大杀四方。我希望的，是我能够把我自己亲身经历的、有感而发的 “职场那些事” 分享给大家，希望能够对大家有所启迪和帮助。 感觉气氛稍微有一点低沉，所以呢，在这次的专栏中，除了我，我们还请到了一个 “重量级” 嘉宾：小灰。 后边的故事呢，将不时的请小灰和它的小伙伴们一起为大家讲述” 程序员情商那些事 “。 最后，欢迎加入《程序员情商课》，我是风落，让我们一起做” 有情商 “的程序高手。 本文来自 风落几番 / 蚂蚁金服测试专家","categories":[{"name":"articles","slug":"articles","permalink":"http://arthurwang.top/categories/articles/"}],"tags":[{"name":"articles","slug":"articles","permalink":"http://arthurwang.top/tags/articles/"},{"name":"EQ","slug":"EQ","permalink":"http://arthurwang.top/tags/EQ/"}]},{"title":"Mac下生成 SSH Key","slug":"mac-sshkeys","date":"2020-01-15T04:57:55.000Z","updated":"2020-02-01T18:42:40.000Z","comments":true,"path":"2020/01/15/mac-sshkeys/","link":"","permalink":"http://arthurwang.top/2020/01/15/mac-sshkeys/","excerpt":"","text":"第一步：检查是否已经存在SSH Key打开电脑终端，输入以下命令： ls -al ~/.ssh 会出现两种情况 第二步：生成/设置SSH Key情况一：已经存在终端出现文件 id_rsa.pub 或 id_dsa.pub，则表示该电脑已经存在SSH Key，此时可继续输入命令： 12&#x2F;&#x2F;将公钥放到剪切板pbcopy &lt; ~&#x2F;.ssh&#x2F;id_rsa.pub 这样你需要的 SSH Key 就已经复制到粘贴板上了. 情况二：不存在终端未出现 id_rsa.pub 或 id_dsa.pub 文件，表示该电脑还没有配置SSH Key，此时需要输入命令： ssh-keygen -t rsa -C &quot;your_full_name@xxxxx.com&quot; （注意，这里的 your_full_name@xxxxx.com 是你自己的邮箱） 默认会在相应路径下（/your_home_path）生成id_rsa和id_rsa.pub两个文件，此时终端会显示： 12Generating public&#x2F;private rsa key pair.Enter file in which to save the key (&#x2F;your_home_path&#x2F;.ssh&#x2F;id_rsa): 连续回车即可，也可能会让你输入密码，密码就是你的开机密码 此时再输入命令：ls -al ~/.ssh 就会出现 id_rsa.pub 和 id_dsa.pub 两个文件 原文：熟睡的毛毛虫","categories":[{"name":"tools","slug":"tools","permalink":"http://arthurwang.top/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"http://arthurwang.top/tags/tools/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-01-01T04:57:55.000Z","updated":"2020-02-02T07:45:19.000Z","comments":true,"path":"2020/01/01/hello-world/","link":"","permalink":"http://arthurwang.top/2020/01/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}